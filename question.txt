11 17 42 48 50 53
----------------------------------

medium 1 
 q 13 
 1

      "function exportSaveState() \n {",
       "var state = { \n };",
       "if(gameState == 1 || gameState == -1 || (gameState === 0 && localStorage.getItem('saveState') !== undefined)) \n { \n state =",
       "hex: $.extend(true, {}, MainHex), \n blocks: $.extend(true, [], blocks),\n score: score, \n	wavegen: waveone, \n gdx: gdx, \n	gdy: gdy, \n",
       "comboTime:settings.comboTime \n	}; \n	state.hex.blocks.map(function(a) \n { \n	for (var i = 0; i < a.length; i++) \n { \n",
       "a[i] = $.extend(true, {}, a[i]); \n }\n a.map(descaleBlock);\n	});",
       "for (var i = 0; i < state.blocks.length; i++) \n {",
       "state.blocks[i] = $.extend(true, {}, state.blocks[i]);",
      "} \n state.blocks.map(descaleBlock); \n	} \n }",

------------------------
easy 2
 q 10
2
       "onMouseMove = (e) => \n {",
       "e.preventDefault();",
       "let targetRect = target.getBoundingClientRect();",
       "let x = e.pageX - targetRect.left + 10;",
       "if (x > targetRect.width) \n { \n x = targetRect.width \n};",
       "else  if (x < 0) \n { x = 0 \n};",
       "btn.x = x - 10; \n btn.style.left = btn.x ; \n let percentPosition = (btn.x + 10) / targetRect.width * 100;",
       "color.style.width = percentPosition ; \n tooltip.style.left = btn.x - 5 ; \n tooltip.style.opacity = 1; \n tooltip.textContent = Math.round(percentPosition);\n}",
       
---------------------------
e 3
 q 5 
3

       "namespace draco \n {",
       "class KeyframeAnimationEncodingTest : public ::testing::Test \n { \n protected: ",
       "KeyframeAnimationEncodingTest() \n { \n }",
       "bool CreateAndAddTimestamps(int32_t num_frames) \n {",
       "timestamps_.resize(num_frames);",
       "for (int i = 0; i < timestamps_.size(); ++i)",
       "timestamps_[i] = static_cast<draco::KeyframeAnimation::TimestampType>(i);",
       "return keyframe_animation_.SetTimestamps(timestamps_); \n }\n}",


-------------------------
m 4
 q 15 
4
      
       "function sortOrder( a, b ) \n {",
       "if ( a === b ) \n {",
       "var hasDuplicate = true;",
       "return 'yes';",
       "} \n var compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?",
       "a.compareDocumentPosition( b ) :1;",
       "if ( compare & 1 ) ",
       "{ \n if ( a == document || a.ownerDocument == document && jQuery.contains( document, a ))",
       "return a;",
       "else if ( b == document || b.ownerDocument == document && jQuery.contains( document, b )) \n{",
       "return b; \n}",
       "return 0; \n}",

------------------------
e 5
 q 4
5
       "int t(int x, int y)",
       "{ \n int z = 1;",
       "while (y > 0) ",
       "{ \n if (y % 2 == 0)",
       "{ \n x = x * x;",
       " y = y / 2; \n }",
       "else \n {",
       "z = z * x;",
       " y = y - 1;    \n } \n }",
       "return z; \n }",

----------------------
e 6
 q 1
6
       "<html>",
       "<head>",
       "<meta charset='UTF-8'>",
       "<title>Type Ahead ðŸ‘€</title>",
      "<link rel='stylesheet' href='style.css'>",
       "</head>",
       "<body>",
       "<form class='search-form'>",
       "<input type='text' class='search' placeholder='City or State'>",
       "<li>Filter for a city</li>",
       "<li>or a state</li>",
       "</ul>",
       "</form>",
       "<script src='./index.js'>",
       "</script>",
       "</body>",
       "</html>",

--------------------------------
h 7
 q 22
 7
       "while(*e != '\0') \n {",
       "if(isalnum(*e))",
       "printf('%c',*e); \n else if(*e == '(')",
       "push(*e);",
       "else if(*e == ')') \n {",
       " while((x = pop()) != '(')",
       "printf('%c', x);}",
       "else \n {",
      "while(priority(stack[top]) >= priority(*e))",
       "printf('%c',pop());",
       "push(*e); \n }",
       "e++; \n  }",

--------------------------------------
m 8
 q 12
8
       "try \n {",
       "const user = await User.findOne({ email }).select('+password');",
       "if (!user)",
       "return next(new ErrorResponse('user doesn't exist', 401));",
       "const isMatch = await user.matchPassword(password);",
       "if (!isMatch) ",
       "return next(new ErrorResponse('Invalid credentials', 401));",
       "sendToken(user, 200, res);",
       "} \n catch (err) \n {",
       "next(err); \n }",

  --------------------------------------

  m 9
  q 14
9
       "<head>",
       "<meta charset='UTF-8'>",
       "<title> BlogIN </title>\n<link rel='icon' href='logo.png' type='image/png' />",
       "<link rel='stylesheet' href='../css/main.css'>",
      "</head>",
       "<body>",
       "<nav class='navbar'>",
       "<div class='navbar-brand'>",
       "<img src='logo.png' alt='' style='width: 120px;height: 120px'> \n </div>",
       "<div class='navbar-links'>",
       "<ul>",
       "<li><a href='/logout'>Logout</a></li>",
       "</ul>\n </div>",
       "</nav>",
       "<div class='container'>",
       "<center>",
       "<p style='font-size:50px;padding-top:40px;font-weight:bold'>Publish your Passions, your way <br> Let's started   Blogging !</p>",
       "</center>",
       "</div>",
       "<script src='./index.js'>",
       "</script>",
       "</body>",


-------------------------------------------
m 11
 q 16
 10
"double function(double x) {",
       "double f1 = x;",
       "for (int i = x - 1; i > 0; i--) {",
       "  f1 *= i;\n }",
      "if (f1 <= 0) ",
       "  f1 = 1;",
       "}",
       "return f1;\n}",
       "double function1(double expected, double x) {",
       "return (std::pow(expected, x) * std::exp(-expected)) / fact(x);\n}",
       "double function2(double expected, double lower, double upper) {",
       " double f2 = 0;",
       "for (int i = lower; i <= upper; i++) {",
       "  f2+= function1(expected, i);\n}",
       "return f2;\n}",

------------------------------------------------
m 12
 q 41
 11
       "return function (array, cmp) {",
        "var gap, current;",
       "cmp = cmp || compare;",
       "for (var k = 0; k < gaps.length; k += 1) {",
       "gap = gaps[k]",
       "for (var i = gap; i < array.length; i += gap) {",
       "current = array[i];",
       "for (var j = i;j >= gap && cmp(array[j - gap], current) > 0; j -= gap) {",
       " array[j] = array[j - gap];\n}",
       "array[j] = current;\n}",
       "}",
       "return array;\n};",

-----------------------------------------------
e 13 
 q 37
12
    "int max = n - 1;\nint min = 0;\nint i;\nint* s = new int[n];\n  int* g = new int[n];",
   " s[0] = -1;\n  g[n - 1] = -1;",
    "for (i = 1; i < n; i++) {\nif (arr[i] <= arr[min]) {",
            "min = i;\ns[i] = -1;",
        "}\nelse\ns[i] = min;",
    "}\nfor (i = n - 2; i >= 0; i--) {\nif (arr[i] >= arr[max]) {",
           " max = i;\ng[i] = -1;\n}",
        "else\ng[i] = max;\n}",
    "for (i = 0; i < n; i++) {",
        "if (s[i] != -1 && g[i] != -1) {",
            "cout << arr[s[i]]<< endl << arr[i] << endl<< arr[g[i]];\nreturn;\n}\n}",
 


---------------------------------------------

h 14 
 q 55
13
       "void function1(vector<vector<int>> matrix)",
       "{",
       "int top = 0, \n left = 0, \n right = matrix[0].size()-1,\n bottom = matrix.size()-1;",
       "while (top<=bottom && left<=right)",
       "{ \n for (int i = left; i <= right; i++){",
       "cout<<matrix[top][i]; \n }",
       "top++;",
       "for (int i = top; i <= bottom; i++) \n cout<<matrix[i][right]; ",
       "right--; \n if(top<=bottom)",
       "for (int i = right ; i >= left; i--)",
       "cout<<matrix[bottom][i]; ",
       "bottom--;",
       "if(left<=right)",
       "for (int i = bottom ; i >= top; i--)",
       "cout<<matrix[i][left];",
      "left++; \n }",
       "}",
       "int main() \n { \n int r, c, temp;",
       "cin >> r >> c;",
       "vector<vector<int>> arr(r);",
       "for (int i = 0; i < r; i++) \n {",
       "for (int j = 0; j < c; j++) \n {",
       "cin >> temp; \n arr[i].push_back(temp); \n } \n }",
       "function1(arr);",
       "return 0; \n }",


-----------------------------------------------------
m 15 
 q 17
14
       "q.push(i); \n } \n }",
       "q.push(it); \n } \n } \n }",
       "if(cnt == N) ",
       "public:",
       "int node = q.front(); ",
       "return false; ",
       "q.pop(); \n  cnt++; ",
      "if(v[it] == 0) { ",
       "queue<int> q; \n vector<int> v(N, 0); \n int cnt = 0;",
       "for(int i = 0;i<N;i++) { \n if(v[i] == 0) {",
       "v[it]++; \n } \n  }",
 "class CodePazuru {",
       "while(!q.empty()) {",
       "bool function1(int N, vector<int> adj[]) {",
       "return true; \n }",
       "v[it]--;",
       "for(auto it : adj[node]) {",
       "for(int i = 0;i<N;i++) { \n for(auto it: adj[i]) { ",
       "};",


-----------------------------------------------------
m 16
 q 43
15
 "class CodePazuru{",
       "public:",
       "void function1(long long a[], long long b[], int n, int m){",
       "int gap = (n + m + 1) / 2;",
       "while (gap) {",
       "int i = 0, j = gap;",
       "while (j < (n + m)) ",
       "{ \n if (i < n && j < n) {",
       "if (a[i] > a[j]) swap(a[i], a[j]); \n }",
       "else if (i < n && j >= n) {",
       "if (a[i] > b[j - n]) swap(a[i], b[j - n]); \n }",
       "else{ ",
       "if (b[i - n] > b[j - n]) swap(b[i - n], b[j - n]); \n }",
       "++i; \n ++j; \n}",
       "gap = gap < 2 ? 0 : (gap + 1) / 2; \n } \n } ",
       "};",

-----------------------------------------------------------------------------
hard 17 
 q 21
 16

"void deleteNode(Node* &root, int key) \n {",
    "if (root == nullptr) { \n return; \n }",
   " if (key < root->data) {\n deleteNode(root->left, key);\n}",
    "else if (key > root->data) {\ndeleteNode(root->right, key);\n}",
    "else {",
       " if (root->left == nullptr && root->right == nullptr)\n{\ndelete root;\nroot = nullptr;\n}",
       " else if (root->left && root->right)\n{",
            "if (root->left->priority < root->right->priority)\n{\nrotateLeft(root);\ndeleteNode(root->left, key);\n}",
           " else {\nrotateRight(root);\ndeleteNode(root->right, key);\n}\n}",
        "else {\nNode* child = (root->left)? root->left: root->right;",
          " Node* curr = root;\nroot = child;",
          "  delete curr;\n}\n}",
"}",


----------------------------------------------------------------------------

medium 18
 q 44
 17
"void function(vector<vector<int>> &mat)\n{",
   " if (mat.size() == 0)\nreturn;",
    "int top = 0, bottom = mat.size() - 1;\nint left = 0, right = mat[0].size() - 1;\nint prev = mat[0][0];",
    "while (true)\n{",
       " if (left > right) \nbreak;",
       " for (int i = left; i <= right; i++) \nswap(mat[top][i], prev);",
        "top++;",
        "if (top > bottom) \nbreak;",
       " for (int i = top; i <= bottom; i++) \nswap(mat[i][right], prev);",
        "right--;",
        "if (left > right) \nbreak;",
        "for (int i = right; i >= left; i--) \nswap(mat[bottom][i], prev);",
        "bottom--;",
        "if (top > bottom) \nbreak;",
       " for (int i = bottom; i >= top; i--) \nswap(mat[i][left], prev);",
        "left++;",
    "}",
    "mat[0][0] = prev;\n}",

---------------------------------------------------------------------------
h 19 
 q 60
 18
"bool isSpace(char c) {"
    "return c == ' ';\n}",
"void function(string &s, int n)\n{",
   " bool space = false;\nint k = 0;",
    "for (int i = 0; i < n; i++)\n{",
        "while (k == 0 && i < n && isSpace(s[i])) {\ni++;\n}",
        "if (isSpace(s[i]))\n{",
            "if (!space)\n{",
                "s[k++] = s[i];\nspace = true;\n}",
        "}\nelse if (ispunct(s[i]))\n{",
           " if (k > 0 && isSpace(s[k-1])) {",
               " s[k-1] = s[i];\n}",
            "else {",
                "s[k++] = s[i];\n}",
            "space = false;\n}",
        "else {",
            "s[k++] = s[i];\nspace = false;",
       " }\n}\ns.erase(s.begin() + k - 1, s.end());",
"}",

------------------------------------------------------------------------------

hard 20 
 q 23
19
"node* function1(node* root)\n{",
    "if (root == NULL)",
        "return root;",
    "if (root->left != NULL) {",
        "node* left = function1(root->left);",
        "for (; left->right != NULL; left = left->right);",       
        "left->right = root;",
       " root->left = left;",
    "}\nif (root->right != NULL) {",
        "node* right = function1(root->right);",
        "for (; right->left != NULL; right = right->left);",
        "right->left = root;",
        "root->right = right;",
    "}\nreturn root;\n}",
"node* function(node* root)",
"{\nif (root == NULL)\nreturn root;",
    "root = function1(root);",
    "while (root->left != NULL)",
       " root = root->left;",
    "return (root);\n}",

--------------------------------------------------------------------

m 21 
 q 18
20
    "int function(int p[], int n, int fr) {",
  "unordered_set<int> s; \n unordered_map<int, int> id; \n int f = 0, m = INT_MIN, val;",
  "for (int i = 0; i < n; i++){",
    "if (s.size() < fr){",
      "if (s.find(p[i]) == s.end()){ \n s.insert(p[i]); \n f++; \n }",
      "id[p[i]] = i; \n }",
    "else{",
    "if (s.find(p[i]) == s.end()){ \n for (auto it = s.begin(); it != s.end(); it++) \n {",
          "if (id[*it] > m) \n {"
            "m = id[*it]; \n val = *it; \n } \n }",   
        "s.erase(val); \n s.insert(p[i]); \n f++;",
    "} \n id[p[i]] = i; \n } \n }",
  "return f; \n }",


------------------------------------------------------------------------

hard 23 
 q 45
21
"bool function_1(Node* node) {",
   " return node->left == nullptr && node->right == nullptr;\n}",
"void function_2(Node* root, Node* &head, Node* &prev)\n{",
    "if (root == nullptr) \nreturn;",
   " if (function_!(root))\n{",
        "if (prev == nullptr) \nhead = root;",
        "else \nprev->right = root;",
        "prev = root;\n}",
    "function_2(root->left, head, prev);",
   " function_2(root->right, head, prev);\n}",
"bool function_3(Node* x, Node* y)\n{",
   " Node* first = nullptr;",
    "Node* prev = nullptr;",
    "function_2(x, first, prev);",
    "Node* second = nullptr;",
    "prev = nullptr;",
   " function_3(y, second, prev);",
   " while (first && second && first->key == second->key)\n{",
        "first = first->right;\nsecond = second->right;\n}",
    "return !first && !second;",
"}",
 
-----------------------------------------------------------------

easy 24
 q 11
 22
"int function(vector<int> &p, int k) \n {",
    "int n = p.size(), pr[k+1][n];",
    "for (int i = 0; i <= k; i++) \n {",
        "for (int j = 0; j < n; j++){",
            "if (i == 0 || j == 0)",
                "pr[i][j] = 0;",
            "else {",
                "int max = 0; \nfor (int k = 0; k < j; k++) \n {",
                    "int curr = p[j] - p[k] + pr[i-1][k];",
                    "if (max < curr)",
                       "max = curr; \n }",
 
                "pr[i][j] = max(pr[i][j-1], max); \n }",
        "} \n } \n return pr[k][n-1]; \n }",

--------------------------------------------

hard 25 
 q 46
23
"Node* function_1(bool mat[][N]){",
   "multimap<int, int> multimap; \n Node* node[N]; \n int row; \n bool parent[N] = false;",
   "for (int i = 0; i < N; i++) \n { \n int sum = 0;",
       "for (int j = 0; j < N; j++)",
            "sum += (int)mat[i][j];",
       "multimap.insert({ sum, i }); \n } \n for (int i = 0; i < N; i++) {",
        "parent[i] = false; \n }",
   "for (auto it: multimap){",
        "row = it.second;",
        "node[row] = new Node(row);",
       " if (it.first == 0) \n continue;",
        "for (int i = 0; i < N; i++){",
            "if (parent[i] == false && mat[row][i]){",
                "if (node[row]->left == nullptr) \n node[row]->left = node[i];",    
                "else \n node[row]->right = node[i];",
                "parent[i] = true; \n }",
        "} \n } \n return node[row]; \n }",

-----------------------------------------------------

easy 26 
 q 6
24

"def func(A):",
    "if len(A) == 0:",
        "return",
    "I = [1] * len(A) \n D = [1] * len(A) \n lbs_len = 1 \n beg = end = 0",
        "if A[i - 1] < A[i]:",
            "I[i] = I[i - 1] + 1",
   " for i in reversed(range(len(A) - 1)):",
       "if A[i] > A[i + 1]:",
            "D[i] = D[i + 1] + 1",
   " for i in range(len(A)):",
        "if lbs_len < I[i] + D[i] - 1:",
            "lbs_len = (I[i] + D[i] - 1)",
            "beg = i - I[i] + 1 \n end = i + D[i] - 1",

---------------------------------------------------------------
easy 27
 q 7 
 25
"def func(A, k):",
 
    "output = [0] * len(A) \n freq = [0] * (k + 1) \n total = 0",
    "for i in A:",
      "freq[i] = freq[i] + 1",

    "for j in range(k + 1):",
       "oldCount = freq[j]",
        "freq[j] = total \n total += oldCount",

   " for it in A:",
       "output[freq[it]] = it \n freq[it] = freq[it] + 1",

    "for a in range(len(A)):",
        "A[a] = output[a]",

-------------------------------------------------------------------

easy 28 
 q 32
26
"def func(X, Y):",
    "if len(X) != len(Y):",
        "return False",
    "dict = {} \n s = set()",
    "for i in range(len(X)):",
        "x = X[i] \n y = Y[i]",
        "if x in dict:",
            "if dict[x] != y:",
                "return False",
        "else:",
            "if y in s:",
                "return False",
            "dict[x] = y \n s.add(y)",
    "return True",

-----------------------------------------------------------------------
hard 29
 q 24
27
"int findMax(vector<vector<int>> const &M) \n {",
    "if (M.size() == 0)",
        "return 0;",
    "int n = M.size(); \n int K[n][n]; \n int max = M[n-1][n-1];",
    "K[n-1][n-1] = M[n-1][n-1];",
    "for (int j = n-2; j >= 0; j--) \n {",
        "if (M[n-1][j] > max) { \n max = M[n-1][j]; \n }",
        "K[n-1][j] = max; \n }",
    "max = M[n-1][n-1];",   
    "for (int i = n-2; i >= 0; i--) \n {",
        "if (M[i][n-1] > max) { \n max = M[i][n-1]; \n }",
        "K[i][n-1] = max; \n }",
    "max = INT_MIN;",           
    "for (int a = n-2; a >= 0; a--) \n {",
        "for (int b = n-2; b >= 0; b--) \n {",
            "if (K[a+1][b+1] - M[a][b] > max)",
                "max = K[a+1][b+1] - M[a][b];",
            "K[a][b] = std::max(M[a][b], std::max(K[a][b+1], K[a+1][b])); \n } \n }",
    "return max; \n }",

-----------------------------------------------------

hard 30
 q 28
28
 "pair<int, int> findMinimumRange(vector<vector<int>> lists) \n {",
      "if (lists.size() == 0)", 
          "return {-1, -1};",
      "int M = lists.size(); \n int high = INT_MIN; \n pair<int, int> p = { 0, INT_MAX };" , "priority_queue<Node, vector<Node>, comp> pq;",
      "for (int i = 0; i < M; i++)\n {",
          "if (lists[i].size() == 0)", 
              "return {-1, -1};",
          "pq.push({lists[i][0], i, 0});",
          "high = max(high, lists[i][0]); \n }",
      "while (true) \n {",
          "int low = pq.top().value; \n int i = pq.top().list_num; \n int j = pq.top().index;",
          "pq.pop();",
          "if (high - low < p.second - p.first) ",
              "p = {low, high};",
          "if (j == lists[i].size() - 1)",
              "return p;",
          "pq.push({lists[i][j + 1], i, j + 1});",
          "high = max(high, lists[i][j + 1]); \n } \n }",

-------------------------------------------------------


hard 31
 q 54
29
"int findMax(vector<vector<int>> const &M) \n {",
    "if (M.size() == 0)",
        "return 0;",
    "int n = M.size(); \n int K[n][n]; \n int max = M[n-1][n-1];",
    "K[n-1][n-1] = M[n-1][n-1];",
    "for (int j = n-2; j >= 0; j--) \n {",
        "if (M[n-1][j] > max) { \n max = M[n-1][j]; \n }",
        "K[n-1][j] = max; \n }",
    "max = M[n-1][n-1];",   
    "for (int i = n-2; i >= 0; i--) \n {",
        "if (M[i][n-1] > max) { \n max = M[i][n-1]; \n }",
        "K[i][n-1] = max; \n }",
    "max = INT_MIN;",           
    "for (int a = n-2; a >= 0; a--) \n {",
        "for (int b = n-2; b >= 0; b--) \n {",
            "if (K[a+1][b+1] - M[a][b] > max)",
                "max = K[a+1][b+1] - M[a][b];",
            "K[a][b] = std::max(M[a][b], std::max(K[a][b+1], K[a+1][b])); \n } \n }",
    "return max; \n }",
-----------------------------------------------------


easy 33
 q 38
 30

"router.post('/add', function(req, res, next) {",
  "var name = req.body.name; \n var errors = req.validationErrors();",
	"req.checkBody('name','Name field is required').notEmpty();",
	"if(errors)",
		"res.render('addpost',{\n'errors': errors\n});",
	" else {\nvar categories = db.get('categories');",
		"categories.insert({\n'name': name,\n}, function(err, post){",
			"if(err)",
				"res.send(err);",
			"else {",
				"req.flash('success','Category Added');",
				"res.location('/');",
			"}\n});\n}",
"});",

------------------------------------------------------------------------------------

easy 34
 q 17
 31

  "<div id='container'>",
      "<div id='namesWrapper#1'>",
        "<h2>ChatIO</h2>",
        "<form id='usernameForm'>",
          "<input type='text' size='35' id='username'>",
          "<input type='submit' value='Submit'>",
        "</form>\n</div>",
        "<div id='chatWrapper#2'>",
          "<div id='chatWindow'></div>\n<form id='messageForm'>",
            "<input type='text' size='35' id='message' placeholder='Say Something...'>",
            "<input type='submit' value='Submit'>\n</form>",
        "</div>\n</div>",
---------------------------------------------------------------------
easy 35
 q 31  
32
"echo 'Total marks : $sum '",
"echo 'Grade : '",
"if [ $sum -gt 200 ]; then",
	"if [ $sum -gt 250 ]; then",
		"if [ $sum -gt 300 ]; then",
			"if [ $sum -gt 350 ]; then",
				"if [ $sum -gt 400 ]; then",
					"if [ $sum -gt 450 ]; then",
						"echo 'S'",
					"else",
						"echo 'A'\nfi",
				"else\necho 'B'",
				"fi\nelse",
				"echo 'C'",
			"fi\nelse\necho 'D'",
		"fi\nelse\necho 'E'",
	"fi\nelse\necho 'F'",
"fi",


-----------------------------------------------------------------------
medium 36
 q 19
33
      "router.post('/add_new_post', (req, res) => {",
      "msg = '';\nif (req.session.loggedIn) {",
        "var title = req.body.title;\nvar content = req.body.content;\nvar publish = req.body.publish;",
        "db.query(",
          "'select id from users where email = ?  ',",
          "[req.session.email],\n(error, results, fields) => {",
            "if (error) ",
              "res.render('challenges/error');",
            "else {\nvar user_id = results[0].id;\nvar published;",
              "if (publish == 'true') published = 1;",
              "else published = 0;",
              "db.query(\n'insert into posts (title,content,user_id,published) values (?,?,?,?)  ',",
                "[title, content, user_id, published],\n(err, results, fields) => {",
                  "if (err) \nres.render('challenges/error');",
                   "else {\nmsg = 'Blog Created Successfully';",
                    "res.redirect("/");",
                  "}\n}\n);\n}",
          "}\n);\n} else ",
        "res.redirect('login');",
    "});",


------------------------------------------------------------------------

easy 37
 q 9 
 34

      "exports.leaderboard = (callback) => {",
      "return pool.query(",
        "'WITH Ranking AS (",
    "SELECT *,",
    " ROW_NUMBER()",
    " OVER( ",
    "ORDER BY Score desc)",
    " AS Ranks",
    " FROM game )",
    " SELECT rollno , score ,ranks",
    " FROM Ranking",
    " WHERE Ranks >= 1 and Ranks <=10",
    "  ORDER BY Ranks ',",
        "callback );",
    "};",

----------------------------------------------

easy 38
 q 35
 35

"exports.protect = async (req, res, next) => {",
  "let token;",
  "if (\nreq.headers.authorization &&\nreq.headers.authorization.startsWith('Bearer')\n)" ,
    "token = req.headers.authorization.split(' ')[1];",
  "if (!token) ",
    "return next(new ErrorResponse('Not authorized to access this route', 401));",
 " try {",
   " const decoded = jwt.verify(token, process.env.JWT_SECRET);",
    "const user = await User.findById(decoded.id);",
    "if (!user) \nreturn next(new ErrorResponse('No user found with this id', 404));",
    "req.user = user;\nnext();",
 " } catch (err) {",
 " return next(new ErrorResponse('Not authorized to access this router', 401));\n}",
"};",

------------------------------------------------------------------

easy 39
 q 39 
 36
"def loginView(request):",
	"if request.method == 'POST':",
		"username = request.POST['username']\npassword = request.POST['password']",
		"user = authenticate(request, username=username, password=password)",
		"if user is not None and user.is_active:",
			"auth.login(request, user)",
			"if user.is_admin or user.is_superuser:",
				"return redirect(' Admin dashboard')",
			"elif user.is_librarian:",
				"return redirect('librarian')",
			"else:",
			    "return redirect('publisher')",
		"else:\nmessages.info(request, 'Invalid username or password')",
		    "return redirect('home')",
--------------------------------------------------------------------------
m 40
 q 2
37
   "function func ( that, fn, init, start, end, inc )",
      "{	\nvar i = start,\nvalue,\nisSet = false;",
        "if ( init !== undefined )", 
            "{",
          "value = init;\nisSet = true;\n}",
        "while ( i !== end ) {",
          "if ( ! that.hasOwnProperty(i) ) ",
            "continue;",
          "value = isSet ",
            "? fn( value, that[i], i, that ) ",
            ":that[i];\nisSet = true;\ni += inc;",
        "}\nreturn value;",
      "}",

    -----------------------------------------------------------

    h 41
     q 58
38
      "struct Job {",
      "int deadline, duration, idx;",
      "bool operator<(Job o) const",
          "return deadline < o.deadline;",  
  "};",
  "vector<int> function(vector<Job> jobs) {",
      "sort(jobs.begin(), jobs.end()); \n set<pair<int,int>> s; \n vector<int> schedule;",
      "for (int i = jobs.size()-1; i >= 0; i--) {",
          "int t = jobs[i].deadline - (i ? jobs[i-1].deadline : 0); \n s.insert(make_pair(jobs[i].duration, jobs[i].idx));",
          "while (t && !s.empty()) { ",
              "auto it = s.begin();",
              "if (it->first <= t) {",
                  "t -= it->first; \n schedule.push_back(it->second) \n }",
               "else {",
                  "s.insert(make_pair(it->first - t, it->second)); \n t = 0; \n }",
              "s.erase(it); \n } \n }",
      "return schedule;",
  "}",
-------------------------------------------------------
 
easy 42
 q 34 
39
"SELECT",
    "d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary",
"FROM",
    "Employee e1",
        "JOIN",
    "Department d ON e1.DepartmentId = d.Id",
"WHERE",
    "3 > (SELECT",
            "COUNT(DISTINCT e2.Salary)",
        "FROM",
            "Employee e2",
        "WHERE",
            "e2.Salary > e1.Salary",
                "AND e1.DepartmentId = e2.DepartmentId",
        ")",
";",

---------------------------------------------------------
easy 43
 q 36
40
"const AuthState = props => {",
 " const initialState = {\ntoken: localStorage.getItem('token'),\nisAuthenticated: null,\nloading: true,\nuser: null,\nerror: null\n};",
  "const [state, dispatch] = useReducer(authReducer, initialState);",
  "const loadUser = async () => {",
    "setAuthToken(localStorage.token);",
  "  try {",
      "const res = await axios.get('/api/auth');",
      "dispatch({\ntype: USER_LOADED,\npayload: res.data\n});",
   " } catch (err) {",
      "dispatch({ type: AUTH_ERROR });",
    "}\n};",


-------------------------------------------------------------------

easy 44
 q  q 33
41
      "export default function App() {",
      "const { register, errors, handleSubmit } = useForm();",
      "const onSubmit = (data) => {",
        "alert(JSON.stringify(data));",
      "};",
      "return (",
       " <form onSubmit={handleSubmit(onSubmit)}>",
          "<FormSection1 register={register} />",
         " <input type='submit' />",
      "  </form>",
    " );\n }",

----------------------------------------------------------------------- 
m 45
 q 20
42
      "useEffect(() => {",
      "if (localStorage.getItem('userInfo')) {\nhistory.push('/');",
      "}\n}, [history]);",
    "const loginHandler = async (e) => {",
      "e.preventDefault();",
     " const config = {",
       " header: {",
         " 'Content-Type': 'application/json',\n}",
     " };",
      "try {",
        "const { data } = await axios.post(\n'/api/auth/login',\n{ email, password },\nconfig\n);",
        "localStorage.setItem('userInfo', JSON.stringify(data));",
       " const userinfo = localStorage.getItem('userInfo');",
       " if (userinfo) {\nhistory.push('/game');\n}",
      "} catch (error) {",
        "setError(error.response.data.error);",
        "setTimeout(() => {\nsetError('');\n}, 5000);",
      "}\n};",


----------------------------------------------------------------------------------------------
easy 46
 q 40
43
"int function(int l, int r, int key, int ar[])\n{",
    "if (r >= l) {",
        "int mid1 = l + (r - l) /3 \n ;int mid2 = r - (r - l) / 3;",
 
        "if (ar[mid1] == key) ",
        " return mid1;",
        
        "if (ar[mid2] == key) ",
        "return mid2;",
        
 
        "if (key < ar[mid1]) ",
            "return function(l, mid1 - 1, key, ar);",
        
        "else if (key > ar[mid2]) ",
            "return function(mid2 + 1, r, key, ar);",
        
        "else ",
           " return function(mid1 + 1, mid2 - 1, key, ar);",
        
   " }\nreturn -1;\n}",
--------------------------------------------------------------------------------------

easy 47
 q 8
44
"void function(int a[], int n)\n{",
    "int i, k, j;",
    "for (i = 1; i < n; i++)",
    "{\nk = a[i];\nj = i - 1;",
    "while (j >= 0 && a[j] > k)",
        {\n a[j + 1] = a[j];\nj = j - 1;\n}",
        "a[j + 1] = k;\n}",

---------------------------------------------------------------------------------------
medium 48
 q 49 
45
"class Solution {",
"public:",
   " double myPow(double x, int n) {",
        "double cur = x, res = 1;\nunsigned int pow;",
        "if(x == 0)", 
        "return 0;",
        "if(n < 0){",
            "cur = 1 / x;\npow = (unsigned int)(-(n + 1)) + 1;"
        "}else if(n == 0)",
            "return 1;",
        "else",
           " pow = n;",
        "while(pow != 0){",
            "if(1&pow) res *= cur;",
            "pow = pow >> 1;\ncur = cur * cur;",
            "}\nreturn res;\n",
    "}",
"};",

-------------------------------------------------------------------------------------------------------
hard 49
 q 57 
46
"class Ques {\nint INF=1e9+5;",
"public:",
    "int function(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {",
        "int n=passingFees.size(); \n vector<vector<pair<int,int>>>g(n); \n  int ans=INF;",
        "for(auto &v:edges){",
            "g[v[0]].push_back({v[1],v[2]}); \n g[v[1]].push_back({v[0],v[2]}); \n }",
        "set<pair<int,pair<int,int>>>st; \n vector<int>t1(n,INF); \n vector<int>fees(n,INF);",
	"st.insert({passingFees[0],{0,0}}); \n t1[0]=0; \n fees[0]=passingFees[0];",
        "while(!st.empty()){",
            "int node=(*st.begin()).second.first,time=(*st.begin()).second.second,cost=(*st.begin()).first;",
            "st.erase(st.begin());",
            "if(node==n-1){",
                "ans=cost;",
                "break;",
	     "} \n if(cost!=fees[node] && time!=t1[node]){ ",
                "continue; \n }",
            "for(auto &child:g[node]){",
                "int cost1=cost+passingFees[child.first]; \n int time1=time+child.second; \n int node1=child.first;",
                "if(time1<=maxTime && (t1[node1]>time1||fees[node1]>cost1)){", 
                    "t1[node1]=min(t1[node1],time1); \n fees[node1]=min(fees[node1],cost1); \n st.insert({cost1,{node1,time1}});",
                "} \n } \n }",
        "if(ans==INF)",
            "ans=-1;",
        "return ans;",
    "} \n };",

------------------------------------------------------------------------
hard 50
 q 29
47
      "class Ques {",
      "public:",
      "vector<vector> dir={{-1,0},{1,0},{0,1},{0,-1}};",
      "bool fn(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int a, int b) \n {",
          "grid2[a][b]=0; \n bool res = true;",
          "for(int i=0;i<4;i++) {",
              "int x = a + dir[i][0]; \n int y = b + dir[i][1];",
              "if(x>=0 && y>=0 && x< grid1.size() && y< grid1[0].size() && grid2[x][y]==1)",   
                  "res&= fin(grid1, grid2, x, y); \n }",
          "return res && (grid1[a][b]==1); \n } ",
      "int function(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {",
          "int n= grid1.size(), m= grid1[0].size(), count = 0;",
          "for(int i=0;i<n;i++) \n {",
              "for(int j=0;j<m;j++) \n {",
                  "if(grid2[i][j]==1)",
                      "count+= fn(grid1, grid2, i, j)?1:0; \n } \n }",
          "return count; \n }",
      "};",
---------------------------------------------------------------------------

hard 51
 q 30 
48
"class Ques {",
"public:",
    "int mind(vector<vector<int>> &mat, int target){",
        "int ind = 0, mn = 0;",
        "for(int i = 0;i<mat[0].size();i++){",
            "if(mat[target][i] > mn){",
                "ind = i; \n mn = mat[target][i]; \n } \n }",
        "return ind; \n }",
    "int ch(vector<vector<int>> &nums, int mid, int target){",
        "if(mid-1 < 0){",
            "if(nums[mid][target]<nums[mid+1][target]) \n return 1;",
            "else\n return 0; \n }",
        "else if(mid+1>nums.size()-1){",
            "if(nums[mid][target] > nums[mid-1][target]) \n return 0;",
            "return -1; \n }",
        "else{",
            "if(nums[mid][target]>nums[mid+1][target] && nums[mid-1][target]< nums[mid][target]) \n return 0;",
            "else if(nums[mid+1][target]>nums[mid-1][target]) \n return 1;",
            "else \n return -1; \n } \n }",
    "vector<int> function(vector<vector<int>>& mat) {\nint l = 0, h = mat.size(), ind = 0;",
        "while(l<h){",
            "int mid = (l+h)/2;",
            "ind = mind(mat, mid);",
            "int t = ch(mat,mid,ind);",
            "if(t==0) \n return {mid,ind};",
            "else if (t==1) \n l = mid+1;",
            "else \n h = mid; \n }",
        "return {l,ind}; \n }",
"};",


---------------------------------------------------------------------------------
medium 52
 q 47
49
"class Ques {",
"public:",
    "int function(int n) {",
        "vector<vector<int>> dp(3,vector<int>(n+1,0));",
        "for(int i=1;i<=2;i++){",
            "for(int j=1;j<=n;j++){",
                "if(i==1) \n dp[i][j] = j;",
                "else if(j==1) \n dp[i][j] =1;",
                "else{",
                    "int mn = INT_MAX;",
                    "for(int mj=j-1,mi=0;mj>=0;mj--,mi++){",
                        "int v1 = dp[i][mj]; \n int v2 = dp[i-1][mi]; \n int mx = max(v1,v2);",
                       "mn = min(mn,mx); \n }",
                    "dp[i][j] = 1 + mn; \n } \n } \n }",
        "return dp[2][n]; \n ",
"};",

--------------------------------------------------------------------------------
hard 53
 q 25
50
"class Ques {",
"public:",
    "bool function(string s) {",
        "vector<vector<int>>p(2001, vector<int>(2001,0));",
        "for(int i=0;i<s.size();i++){",
            "string s1 = s.substr(i,1); \n p[i][i] = 1; \n int l=i-1, r = i+1;",
            "while(l>=0 &&  r<s.size() && s[l]==s[r]){",
                "p[l][r] = 1;",
                "l--; \n r++; \n }",
            "int left = i, right = i+1;\n while(left>=0 && right<s.size() && s[left]==s[right]){",
                "p[left][right] = 1;",
                "left--; right++; \n } \n }",
        "int n = s.size(); \n for(int i=0;i<n-2;i++){",
            "for(int j=i+1;j<n-1;j++)",
                "if(p[0][i]==1 && p[i+1][j]==1 && p[j+1][n-1]==1) ",
			"return true; \n }",
        "return false; \n }",
"};",

----------------------------------------------------------------------------
medium 54
 q 27
51
"class Ques {",
"public:",
    "std::vector<int> function(std::vector<int>& encoded) { \n std::vector<int> perm(n, 0);",
        "const int n = encoded.size() + 1; \n int x = 0, e=0",
        "for ( int i = 1; i <= n; ++i )",
            "x ^= i;\nfor ( int i = 1; i < encoded.size(); i += 2 )",
            "e ^= encoded[i];",
        "int po = x ^ e;",
	"perm[0] = po;",
        "for ( int i = 1; i < n; ++i )",
            "perm[i] = perm[i-1] ^ encoded[i-1];",
        "return perm; \n }",
"};",

-----------------------------------------------------------------------------
hard 55
 q 52
52
"int function(vector<vector<int>>& grid) {",
    "int n = grid.size(); \n vector<int> zeros(n, 0); \n int ans = 0;",
    "if(n == 0)",
        "return 0;",
    "for(int i=0; i<n; i++){",
        "for(int j=n-1; j>=1; j--){",
            "if(grid[i][j] == 0)",
                "zeros[i]++;",
            "else",
                "break; \n } \n }",
    "for(int i=0; i<n-1; i++){",
        "int req = n-i-1; \n int k=i;",
        "while(k < n && min(req, zeros[k]) != req)",
            "k++;",
        "if(k == n)",
            "return -1;",
        "ans += (k - i);",
        "while(k > i){",
            "swap(zeros[k], zeros[k-1]);",
            "k--; \n } \n }",
    "return ans; \n }",
-----------------------------------------------------------------------------

hard 56
 q 3
53
    "setInterval(() => {",
        "counter++;",
        "var minutesTimeSpan = counter * 1000;",
        "currentDate = new Date();",
        "currentDate.setTime(currentDate.getTime() + minutesTimeSpan);",
        "countDownDate = currentDate.getTime();",
        "refreshTime();",
   " }, 1000);",


-----------------------------------------------------

hard 57
 q 59
54
"typedef struct func {",
    "uint8_t s1Cnt; \n uint8_t s2Cnt; \n uint8_t s3Cnt;",
    "func(uint8_t s1C, uint8_t s2C, uint8_t s3C) {",
        "s1Cnt = s1C; \n s2Cnt = s2C; \n s3Cnt = s3C; \n }",
"} func;",
"class Ques {",
"public:",
    "bool function(string s1, string s2, string s3) {",
        "uint8_t s1Size = s1.size(); \n uint8_t s2Size = s2.size(); \n uint8_t s3Size = s3.size();",
        "vector<vector<bool>> memo (s1Size + 1, vector<bool>(s2Size + 1)); \n stack<func> buffStk;",
        "buffStk.push(func(0, 0, 0));",
        "while (!buffStk.empty()) {",
            "func currBuff = buffStk.top();",
            "buffStk.pop();",
            "uint8_t currS1Cnt = currBuff.s1Cnt; \n uint8_t currS2Cnt = currBuff.s2Cnt;",
	    "uint8_t currS3Cnt = currBuff.s3Cnt; \n if (currS1Cnt == s1Size && currS2Cnt == s2Size && currS3Cnt == s3Size)",
                "return true;",
            "if (memo[currS1Cnt][currS2Cnt]) \n continue;",
            "memo[currS1Cnt][currS2Cnt] = true;",
            "if (currS1Cnt < s1Size && s1[currS1Cnt] == s3[currS3Cnt]) {",
                "buffStk.push(func(",
                    "currS1Cnt + 1,",
                    "currS2Cnt,",
                    "currS3Cnt + 1",
                ")); \n } \n if (currS2Cnt < s2Size && s2[currS2Cnt] == s3[currS3Cnt]) {",
                "buffStk.push(func(currS1Cnt, currS2Cnt + 1, \n currS3Cnt + 1)); \n }",
        "} \n return false; \n }",
"};",

--------------------------------------------------------------------

hard 58
 q 56
55

"class Ques {",
    "public int function(int[][] grid) {",
        "int m = grid.length; \n int n = grid[0].length; \n int dp[][][] = new int[m][n][n];",
        "for (int row = m - 1; row >= 0; row--) {",
            "for (int col1 = 0; col1 < n; col1++) {",
                "for (int col2 = 0; col2 < n; col2++) {",
                    "int result = 0;",
                    "result += grid[row][col1]; \n if (col1 != col2)",
                        "result += grid[row][col2];",
                    "if (row != m - 1) {",
                        "int max = 0;",
                        "for (int newCol1 = col1 - 1; newCol1 <= col1 + 1; newCol1++) {",
                            "for (int newCol2 = col2 - 1; newCol2 <= col2 + 1; newCol2++) {",
                                "if (newCol1 >= 0 && newCol1 < n && newCol2 >= 0 && newCol2 < n) ",
                                    "max = Math.max(max, dp[row + 1][newCol1][newCol2]); \n } \n }",
                        "result += max; \n }",
                    "dp[row][col1][col2] = result; \n }",
            "} \n }",
        "return dp[0][0][n - 1]; \n } \n }",

-----------------------------------------------------------------------
hard 59
q 51
56
"class Ques {",
"public:",
    "int function(vector<vector<int>>& grid) {",
        "int m = grid.size(), n = grid[0].size(), ans =0; \n vector<vector<int> > dp(m, vector<int>(n, INT_MAX)); \n  int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};",
        "queue<vector<int> > q;",
        "for(int i=0; i<m; ++i) {",
            "for(int j=0; j<n; ++j) {",
                "if(grid[i][j] == 1) {",
                    "dp[i][j] = 0; \n q.push({i, j, 0}); \n } \n } \n",
        "while(!q.empty()) {",
            "auto p = q.front();",
            "q.pop();",
            "for(int k=0; k<4; ++k) {",
                "int nx = p[0] + dx[k], ny = p[1] + dy[k], ndis = p[2] + 1;",
                "if(nx < 0 || nx >= m || ny < 0 || ny >= n) \n continue; \n if(ndis < dp[nx][ny]) {",
                    "dp[nx][ny] = ndis;",
                    "q.push({nx, ny, ndis});",
                    "ans = max(ans, ndis); \n } \n } \n }",
        "return ans == 0 ? -1 : ans; \n }",
"};",

-----------------------------------------------------------------------
hard 60
q 26
57
"vector<int> DIR = {0, 1, 0, -1, 0};",
    "int function(vector<vector<int>>& grid) {",
        "int m = grid.size(), \n n = grid[0].size(), \n count=-1, \n f=0; \n queue<pair<int, int>> q;",
        "for (int r = 0; r < m; ++r) {",
            "for (int c = 0; c < n; ++c) {",
                "if (grid[r][c] == 2)",
		 "q.emplace(r, c);",
                "else if(grid[r][c] == 1)",
		 "f++; \n } \n }",
       
        "while (!q.empty()) {",
            "int sz=q.size();",
            "while(sz--) {",
                "queue<pair<int, int>> que;",
                "auto [r, c] = q.front(); q.pop();",
                "for (int i = 0; i < 4; ++i) {",
                    "int nr = r + DIR[i], nc = c + DIR[i+1];",

                    "if (nr < 0 || nr == m || nc < 0 || nc == n || grid[nr][nc] != 1)",
			 "continue;",
                    "grid[nr][nc] = grid[r][c];",
                    "q.emplace(nr, nc);",
                    "f--; \n } \n }",
            
            "count++; \n }",
        
        "if(f>0)",
 	"return -1;",
        "return max(0,count); \n }",
   ---------------------------------------------------------------
q 48

   "int function(int arr[], int n)\n{",
      "int m,count=0;",
      "for(int i=0;i<n;i++){",
          "if(i==0){",
              "m=arr[i];\ncount=1;",
          "}\nelse if (m==arr[i]){",
             " count++; }",
          "else",
              "count--;",
      "}\ncount = 0;",
    "for (int i = 0; i < n; i++) {\nif (arr[i] == m) ",
        "count++;\n}",
    "if (count > n / 2)",
      "return m;",
    "else\nreturn -1;\n}",

    ---------------------------------------------------------

    q 50
    
       "func function(n uint, fp float64) *c {",
	"b := uint(4)",
	"f := fingerprintLength(b, fp)",
	"m := nextPower(n / f * 8)",
	"buckets := make([]bucket, m)",
	"for i := uint(0); i < m; i++ {",
		"buckets[i] = make(bucket, b)",
	"}\nreturn &c{",
		"buckets: buckets,\nm:       m,\nb: b,\nf:   f\nn:       n,",
	"}\n}",

    --------------------------------------------------

    q 53

    "class Node{",
    "public :\nNode *left;\nNode *right;\nint data;\nbool rightThread;",
     "Node(int data){",
       " this->data = data;\nrightThread = false;",
        "this->left = nullptr ;\nthis->right = nullptr ;\n},
"} ;\n Node* leftMostNode(Node *node){",
        "if(node==nullptr) \n return nullptr;"
        "else{\nwhile(node->left!=nullptr)",
        "{\nnode = node->left;\n}",
            "return node;\n}\n}",

"class bst {\npublic :",

    "bst(){\n}",
        "void inorder(Node *root, Node *previous){",

        "if(root==nullptr)\nreturn;",
        "else{\n inorder(root->right, previous);",
           " if(root->right==nullptr &&  previous!=nullptr){",
               " root->right = previous;",
                "root->rightThread=true;",
           " }\ninorder(root->left, root);",
        "}\nvoid convert(Node *root){",
        "inorder(root, nullptr);\n}\n  } ;",




