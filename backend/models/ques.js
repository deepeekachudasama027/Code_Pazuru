const mongoose = require("mongoose");

const quesSchema = new mongoose.Schema({
  level: {
    type: Number,
    required: true,
    trim: true,
  },
  day: {
    type: Number,
    required: true,
    trim: true,
  },
  code: [String],
  order: [String],
});

module.exports = Question = mongoose.model("question", quesSchema);
// Question.insertMany([
//   {
//     day: 1,
//     level: 1,
//     order: [
//  "class Solution \n {",
//   "public:",
//       " int function(int n) \n{",
//            "int x1=0;\nint x2=1;\nint result=0;",
//             "for(int i=1;i<=n;i++)",
//             "{",
//                 "result=x2+x1;",
//                 "x1=x2;",
//                " x2=result;",
//             "}\nreturn result;",
//         "}\n};",
//     ],
//     code: [
//             "{",
//         "}\n};",
//  "class Solution \n {",
//       " int function(int n) \n{",
//   "public:",
//                " x2=result;",
//                 "result=x2+x1;",
//            "int x1=0;\nint x2=1;\nint result=0;",
//             "for(int i=1;i<=n;i++)",
//             "}\nreturn result;",
//                 "x1=x2;",
//     ],
//   },
// ]);

// Question.insertMany([
//   {
//     level: 2,
//     day: 1,
//     order: [
//       "function func ( that, fn, init, start, end, inc )",
//       "{	\nvar i = start,\nvalue,\nisSet = false;",
//       "if ( init !== undefined )",
//       "{",
//       "value = init;\nisSet = true;\n}",
//       "while ( i !== end ) {",
//       "if ( ! that.hasOwnProperty(i) ) ",
//       "continue;",
//       "value = isSet ",
//       "? fn( value, that[i], i, that ) ",
//       ":that[i];\nisSet = true;\ni += inc;",
//       "}\nreturn value;",
//       "}",
//     ],
//     code: [
//       "? fn( value, that[i], i, that ) ",
//       "value = init;\nisSet = true;\n}",
//       "while ( i !== end ) {",
//       ":that[i];\nisSet = true;\ni += inc;",
//       "{",
//       "if ( init !== undefined )",
//       "continue;",
//       "if ( ! that.hasOwnProperty(i) ) ",
//       "}",
//       "{	\nvar i = start,\nvalue,\nisSet = false;",
//       "function func ( that, fn, init, start, end, inc )",
//       "value = isSet ",
//       "}\nreturn value;",
//     ],
//   },
// ]);

// Question.insertMany([
//   {
//     level: 3,
//     day: 1,
//     order: [
//       "setInterval(() => {",
//       "counter++;",
//       "var minutesTimeSpan = counter * 1000;",
//       "currentDate = new Date();",
//       "currentDate.setTime(currentDate.getTime() + minutesTimeSpan);",
//       "countDownDate = currentDate.getTime();",
//       "refreshTime();",
//       " }, 1000);",
//     ],
//     code: [
//       "var minutesTimeSpan = counter * 1000;",
//       " }, 1000);",
//       "countDownDate = currentDate.getTime();",
//       "refreshTime();",
//       "currentDate.setTime(currentDate.getTime() + minutesTimeSpan);",
//       "setInterval(() => {",
//       "counter++;",
//       "currentDate = new Date();",
//     ],
//   },
// ]);

// Question.insertMany([
//   {
//     level: 4,
//     day: 1,
//     order: [
//       "int t(int x, int y)",
//       "{ \n int z = 1;",
//       "while (y > 0) ",
//       "{ \n if (y % 2 == 0)",
//       "{ \n x = x * x;",
//       " y = y / 2; \n }",
//       "else \n {",
//       "z = z * x;",
//       " y = y - 1;    \n } \n }",
//       "return z; \n }",
//     ],
//     code: [
//       " y = y / 2; \n }",
//       "else \n {",
//       "return z; \n }",
//       "while (y > 0) ",
//       "{ \n x = x * x;",
//       "z = z * x;",
//       "{ \n if (y % 2 == 0)",
//       "int t(int x, int y)",
//       "{ \n int z = 1;",
//       " y = y - 1;    \n } \n }",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 5,
//     day: 1,
//     order: [
//       "namespace draco \n {",
//       "class KeyframeAnimationEncodingTest : public ::testing::Test \n { \n protected: ",
//       "KeyframeAnimationEncodingTest() \n { \n }",
//       "bool CreateAndAddTimestamps(int32_t num_frames) \n {",
//       "timestamps_.resize(num_frames);",
//       "for (int i = 0; i < timestamps_.size(); ++i)",
//       "timestamps_[i] = static_cast<draco::KeyframeAnimation::TimestampType>(i);",
//       "return keyframe_animation_.SetTimestamps(timestamps_); \n }\n}",
//     ],
//     code: [
//       "return keyframe_animation_.SetTimestamps(timestamps_); \n }\n}",
//       "bool CreateAndAddTimestamps(int32_t num_frames) \n {",
//       "timestamps_.resize(num_frames);",
//       "namespace draco \n {",
//       "timestamps_[i] = static_cast<draco::KeyframeAnimation::TimestampType>(i);",
//       "KeyframeAnimationEncodingTest() \n { \n }",
//       "class KeyframeAnimationEncodingTest : public ::testing::Test \n { \n protected: ",
//       "for (int i = 0; i < timestamps_.size(); ++i)",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 6,
//     day: 1,
//     order: [
//       "def func(A):",
//       "if len(A) == 0:",
//       "return",
//       "I = [1] * len(A) \n D = [1] * len(A) \n lbs_len = 1 \n beg = end = 0",
//       "if A[i - 1] < A[i]:",
//       "I[i] = I[i - 1] + 1",
//       " for i in reversed(range(len(A) - 1)):",
//       "if A[i] > A[i + 1]:",
//       "D[i] = D[i + 1] + 1",
//       " for i in range(len(A)):",
//       "if lbs_len < I[i] + D[i] - 1:",
//       "lbs_len = (I[i] + D[i] - 1)",
//       "beg = i - I[i] + 1 \n end = i + D[i] - 1",
//     ],
//     code: [
//       "if len(A) == 0:",
//       "I = [1] * len(A) \n D = [1] * len(A) \n lbs_len = 1 \n beg = end = 0",
//       "I[i] = I[i - 1] + 1",
//       "if lbs_len < I[i] + D[i] - 1:",
//       "if A[i - 1] < A[i]:",
//       "def func(A):",
//       "if A[i] > A[i + 1]:",
//       " for i in range(len(A)):",
//       "lbs_len = (I[i] + D[i] - 1)",
//       "return",
//       " for i in reversed(range(len(A) - 1)):",
//       "D[i] = D[i + 1] + 1",
//       "beg = i - I[i] + 1 \n end = i + D[i] - 1",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 7,
//     day: 1,
//     order: [
//       "def func(A, k):",
//       "output = [0] * len(A) \n freq = [0] * (k + 1) \n total = 0",
//       "for i in A:",
//       "freq[i] = freq[i] + 1",
//       "for j in range(k + 1):",
//       "oldCount = freq[j]",
//       "freq[j] = total \n total += oldCount",
//       " for it in A:",
//       "output[freq[it]] = it \n freq[it] = freq[it] + 1",
//       "for a in range(len(A)):",
//       "A[a] = output[a]",
//     ],
//     code: [
//       "for i in A:",
//       "output = [0] * len(A) \n freq = [0] * (k + 1) \n total = 0",
//       "def func(A, k):",
//       "freq[j] = total \n total += oldCount",
//       "A[a] = output[a]",
//       "oldCount = freq[j]",
//       " for it in A:",
//       "freq[i] = freq[i] + 1",
//       "for j in range(k + 1):",
//       "for a in range(len(A)):",
//       "output[freq[it]] = it \n freq[it] = freq[it] + 1",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 8,
//     day: 1,
//     order: [
//       "void function(int a[], int n)\n{",
//       "int i, k, j;",
//       "for (i = 1; i < n; i++)",
//       "{\nk = a[i];\nj = i - 1;",
//       "while (j >= 0 && a[j] > k)",
//       "{\n a[j + 1] = a[j];\nj = j - 1;\n}",
//       "a[j + 1] = k;\n}",
//     ],
//     code: [
//       "{\n a[j + 1] = a[j];\nj = j - 1;\n}",
//       "{\nk = a[i];\nj = i - 1;",
//       "int i, k, j;",
//       "while (j >= 0 && a[j] > k)",
//       "for (i = 1; i < n; i++)",
//       "a[j + 1] = k;\n}",
//       "void function(int a[], int n)\n{",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 9,
//     day: 1,
//     order: [
//       "exports.leaderboard = (callback) => {",
//       "return pool.query(",
//       "'WITH Ranking AS (",
//       "SELECT *,",
//       " ROW_NUMBER()",
//       " OVER( ",
//       "ORDER BY Score desc)",
//       " AS Ranks",
//       " FROM game )",
//       " SELECT rollno , score ,ranks",
//       " FROM Ranking",
//       " WHERE Ranks >= 1 and Ranks <=10",
//       "  ORDER BY Ranks ',",
//       "callback );",
//       "};",
//     ],
//     code: [
//       "  ORDER BY Ranks ',",
//       "};",
//       " ROW_NUMBER()",
//       "'WITH Ranking AS (",
//       " FROM Ranking",
//       " WHERE Ranks >= 1 and Ranks <=10",
//       "SELECT *,",
//       " AS Ranks",
//       " FROM game )",
//       " OVER( ",
//       "return pool.query(",
//       "ORDER BY Score desc)",
//       " SELECT rollno , score ,ranks",
//       "exports.leaderboard = (callback) => {",
//       "callback );",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 10,
//     day: 1,
//     order: [
//       "onMouseMove = (e) => \n {",
//       "e.preventDefault();",
//       "let targetRect = target.getBoundingClientRect();",
//       "let x = e.pageX - targetRect.left + 10;",
//       "if (x > targetRect.width) \n { \n x = targetRect.width \n};",
//       "else  if (x < 0) \n { x = 0 \n};",
//       "btn.x = x - 10; \n btn.style.left = btn.x ; \n let percentPosition = (btn.x + 10) / targetRect.width * 100;",
//       "color.style.width = percentPosition ; \n tooltip.style.left = btn.x - 5 ; \n tooltip.style.opacity = 1; \n tooltip.textContent = Math.round(percentPosition);\n}",
//     ],
//     code: [
//       "e.preventDefault();",
//       "onMouseMove = (e) => \n {",
//       "else  if (x < 0) \n { x = 0 \n};",
//       "let x = e.pageX - targetRect.left + 10;",
//       "let targetRect = target.getBoundingClientRect();",
//       "color.style.width = percentPosition ; \n tooltip.style.left = btn.x - 5 ; \n tooltip.style.opacity = 1; \n tooltip.textContent = Math.round(percentPosition);\n}",
//       "if (x > targetRect.width) \n { \n x = targetRect.width \n};",
//       "btn.x = x - 10; \n btn.style.left = btn.x ; \n let percentPosition = (btn.x + 10) / targetRect.width * 100;",
//     ],
//   },
// ]);

// Question.insertMany([
//   {
//     level: 11,
//     day: 1,
//     order: [
//       "int function(vector<int> &p, int k) \n {",
//       "int n = p.size(), pr[k+1][n];",
//       "for (int i = 0; i <= k; i++) \n {",
//       "for (int j = 0; j < n; j++){",
//       "if (i == 0 || j == 0)",
//       "pr[i][j] = 0;",
//       "else {",
//       "int max = 0; \nfor (int k = 0; k < j; k++) \n {",
//       "int curr = p[j] - p[k] + pr[i-1][k];",
//       "if (max < curr)",
//       "max = curr; \n }",

//       "pr[i][j] = max(pr[i][j-1], max); \n }",
//       "} \n } \n return pr[k][n-1]; \n }",
//     ],
//     code: [
//       "int curr = p[j] - p[k] + pr[i-1][k];",
//       "if (max < curr)",
//       "pr[i][j] = 0;",
//       "for (int j = 0; j < n; j++){",
//       "else {",
//       "pr[i][j] = max(pr[i][j-1], max); \n }",
//       "if (i == 0 || j == 0)",
//       "} \n } \n return pr[k][n-1]; \n }",
//       "int n = p.size(), pr[k+1][n];",
//       "int max = 0; \nfor (int k = 0; k < j; k++) \n {",
//       "for (int i = 0; i <= k; i++) \n {",
//       "int function(vector<int> &p, int k) \n {",
//       "max = curr; \n }",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 12,
//     day: 1,
//     order: [
//       "try \n {",
//       "const user = await User.findOne({ email }).select('+password');",
//       "if (!user)",
//       "return next(new ErrorResponse('user doesn't exist', 401));",
//       "const isMatch = await user.matchPassword(password);",
//       "if (!isMatch) ",
//       "return next(new ErrorResponse('Invalid credentials', 401));",
//       "sendToken(user, 200, res);",
//       "} \n catch (err) \n {",
//       "next(err); \n }",
//     ],
//     code: [
//       "return next(new ErrorResponse('user doesn't exist', 401));",
//       "sendToken(user, 200, res);",
//       "const user = await User.findOne({ email }).select('+password');",
//       "const isMatch = await user.matchPassword(password);",
//       "if (!isMatch) ",
//       "try \n {",
//       "if (!user)",
//       "} \n catch (err) \n {",
//       "return next(new ErrorResponse('Invalid credentials', 401));",
//       "next(err); \n }",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 13,
//     day: 1,
//     order: [
//       "function exportSaveState() \n {",
//       "var state = { \n };",
//       "if(gameState == 1 || gameState == -1 || (gameState === 0 && localStorage.getItem('saveState') !== undefined)) \n { \n state =",
//       "hex: $.extend(true, {}, MainHex), \n blocks: $.extend(true, [], blocks),\n score: score, \n	wavegen: waveone, \n gdx: gdx, \n	gdy: gdy, \n",
//       "comboTime:settings.comboTime \n	}; \n	state.hex.blocks.map(function(a) \n { \n	for (var i = 0; i < a.length; i++) \n { \n",
//       "a[i] = $.extend(true, {}, a[i]); \n }\n a.map(descaleBlock);\n	});",
//       "for (var i = 0; i < state.blocks.length; i++) \n {",
//       "state.blocks[i] = $.extend(true, {}, state.blocks[i]);",
//       "} \n state.blocks.map(descaleBlock); \n	} \n }",
//     ],
//     code: [
//       "hex: $.extend(true, {}, MainHex), \n blocks: $.extend(true, [], blocks),\n score: score, \n	wavegen: waveone, \n gdx: gdx, \n	gdy: gdy, \n",
//       "if(gameState == 1 || gameState == -1 || (gameState === 0 && localStorage.getItem('saveState') !== undefined)) \n { \n state =",
//       "state.blocks[i] = $.extend(true, {}, state.blocks[i]);",
//       "a[i] = $.extend(true, {}, a[i]); \n }\n a.map(descaleBlock);\n	});",
//       "function exportSaveState() \n {",
//       "} \n state.blocks.map(descaleBlock); \n	} \n }",
//       "comboTime:settings.comboTime \n	}; \n	state.hex.blocks.map(function(a) \n { \n	for (var i = 0; i < a.length; i++) \n { \n",
//       "var state = { \n };",
//       "for (var i = 0; i < state.blocks.length; i++) \n {",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 14,
//     day: 1,
//     order: [
// "public class Solution {",
//   "public int item(int[] ratings) {",
//       "int[] items = new int[ratings.length];\nboolean hasChanged = true;",
//       "Arrays.fill(items, 1);",
//       "while (hasChanged) {",
//           "hasChanged = false;",
//           "for (int i = 0; i < ratings.length; i++) {",
//               "if (i != ratings.length - 1 && ratings[i] > ratings[i + 1] && items[i] <= items[i + 1]) {",
//                   "items[i] = items[i + 1] + 1;\nhasChanged = true;",
//               "}",
//               "if (i > 0 && ratings[i] > ratings[i - 1] && items[i] <= items[i - 1]) {",
//                   "items[i] = items[i - 1] + 1;\nhasChanged = true;",
//               "}\n}\n}",
//       "int sum = 0;",
//      "for (int item : items) sum += item;",
//      "return sum;",
//   "}\n}",
//     ],
//     code: [
//               "if (i > 0 && ratings[i] > ratings[i - 1] && items[i] <= items[i - 1]) {",
//                   "items[i] = items[i + 1] + 1;\nhasChanged = true;",
// "public class Solution {",
//      "return sum;",
//           "hasChanged = false;",
//       "Arrays.fill(items, 1);",
//       "int[] items = new int[ratings.length];\nboolean hasChanged = true;",
//               "}",
//   "public int item(int[] ratings) {",
//       "int sum = 0;",
//       "while (hasChanged) {",
//               "if (i != ratings.length - 1 && ratings[i] > ratings[i + 1] && items[i] <= items[i + 1]) {",
//           "for (int i = 0; i < ratings.length; i++) {",
//               "}\n}\n}",
//      "for (int item : items) sum += item;",
//                   "items[i] = items[i - 1] + 1;\nhasChanged = true;",
//   "}\n}",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 15,
//     day: 1,
//     order: [
//       "function sortOrder( a, b ) \n {",
//       "if ( a === b ) \n {",
//       "var hasDuplicate = true;",
//       "return 'yes';",
//       "} \n var compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?",
//       "a.compareDocumentPosition( b ) :1;",
//       "if ( compare & 1 ) ",
//       "{ \n if ( a == document || a.ownerDocument == document && jQuery.contains( document, a ))",
//       "return a;",
//       "else if ( b == document || b.ownerDocument == document && jQuery.contains( document, b )) \n{",
//       "return b; \n}",
//       "return 0; \n}",
//     ],
//     code: [
//       "if ( a === b ) \n {",
//       "} \n var compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?",
//       "return b; \n}",
//       "function sortOrder( a, b ) \n {",
//       "var hasDuplicate = true;",
//       "return 0; \n}",
//       "if ( compare & 1 ) ",
//       "else if ( b == document || b.ownerDocument == document && jQuery.contains( document, b )) \n{",
//       "{ \n if ( a == document || a.ownerDocument == document && jQuery.contains( document, a ))",
//       "a.compareDocumentPosition( b ) :1;",
//       "return a;",
//       "return 'yes';",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 16,
//     day: 1,
//     order: [
//       "double function(double x) {",
//       "double f1 = x;",
//       "for (int i = x - 1; i > 0; i--) {",
//       "  f1 *= i;\n }",
//       "if (f1 <= 0) ",
//       "  f1 = 1;",
//       "}",
//       "return f1;\n}",
//       "double function1(double expected, double x) {",
//       "return (std::pow(expected, x) * std::exp(-expected)) / function(x);\n}",
//       "double function2(double expected, double lower, double upper) {",
//       " double f2 = 0;",
//       "for (int i = lower; i <= upper; i++) {",
//       "  f2+= function1(expected, i);\n}",
//       "return f2;\n}",
//     ],
//     code: [
//       "}",
//       "return (std::pow(expected, x) * std::exp(-expected)) / function(x);\n}",
//       "double f1 = x;",
//       "return f2;\n}",
//       "return f1;\n}",
//       "if (f1 <= 0) ",
//       "double function2(double expected, double lower, double upper) {",
//       "double function1(double expected, double x) {",
//       "for (int i = lower; i <= upper; i++) {",
//       "  f2+= function1(expected, i);\n}",
//       "  f1 = 1;",
//       "double function(double x) {",
//       "  f1 *= i;\n }",
//       " double f2 = 0;",
//       "for (int i = x - 1; i > 0; i--) {",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 17,
//     day: 1,
//     order: [
//       "class CodePazuru {",
//       "public:",
//       "bool function1(int N, vector<int> adj[]) {",
//       "queue<int> q; \n vector<int> v(N, 0); \n int cnt = 0;",
//       "for(int i = 0;i<N;i++) { \n for(auto it: adj[i]) { ",
//       "v[it]++; \n } \n  }",
//       "for(int i = 0;i<N;i++) { \n if(v[i] == 0) {",
//       "q.push(i); \n } \n }",
//       "while(!q.empty()) {",
//       "int node = q.front(); ",
//       "q.pop(); \n  cnt++; ",
//       "for(auto it : adj[node]) {",
//       "v[it]--;",
//       "if(v[it] == 0) { ",
//       "q.push(it); \n } \n } \n }",
//       "if(cnt == N) ",
//       "return false; ",
//       "return true; \n }",
//       "};",
//     ],
//     code: [
//       "queue<int> q; \n vector<int> v(N, 0); \n int cnt = 0;",
//       "q.pop(); \n  cnt++; ",
//       "for(auto it : adj[node]) {",
//       "q.push(i); \n } \n }",
//       "v[it]++; \n } \n  }",
//       "bool function1(int N, vector<int> adj[]) {",
//       "};",
//       "if(cnt == N) ",
//       "return true; \n }",
//       "for(int i = 0;i<N;i++) { \n for(auto it: adj[i]) { ",
//       "public:",
//       "class CodePazuru {",
//       "return false; ",
//       "v[it]--;",
//       "int node = q.front(); ",
//       "q.push(it); \n } \n } \n }",
//       "while(!q.empty()) {",
//       "for(int i = 0;i<N;i++) { \n if(v[i] == 0) {",
//       "if(v[it] == 0) { ",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 18,
//     day: 1,
//     order: [
//       "int function(int p[], int n, int fr) {",
//       "unordered_set<int> s; \n unordered_map<int, int> id; \n int f = 0, m = INT_MIN, val;",
//       "for (int i = 0; i < n; i++){",
//       "if (s.size() < fr){",
//       "if (s.find(p[i]) == s.end()){ \n s.insert(p[i]); \n f++; \n }",
//       "id[p[i]] = i; \n }",
//       "else{",
//       "if (s.find(p[i]) == s.end()){ \n for (auto it = s.begin(); it != s.end(); it++) \n {",
//       "if (id[*it] > m) \n {",
//       "m = id[*it]; \n val = *it; \n } \n }",
//       "s.erase(val); \n s.insert(p[i]); \n f++;",
//       "} \n id[p[i]] = i; \n } \n }",
//       "return f; \n }",
//     ],
//     code: [
//       "} \n id[p[i]] = i; \n } \n }",
//       "id[p[i]] = i; \n }",
//       "if (s.find(p[i]) == s.end()){ \n for (auto it = s.begin(); it != s.end(); it++) \n {",
//       "int function(int p[], int n, int fr) {",
//       "for (int i = 0; i < n; i++){",
//       "return f; \n }",
//       "else{",
//       "s.erase(val); \n s.insert(p[i]); \n f++;",
//       "unordered_set<int> s; \n unordered_map<int, int> id; \n int f = 0, m = INT_MIN, val;",
//       "if (s.find(p[i]) == s.end()){ \n s.insert(p[i]); \n f++; \n }",
//       "if (id[*it] > m) \n {",
//       "m = id[*it]; \n val = *it; \n } \n }",
//       "if (s.size() < fr){",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 19,
//     day: 1,
//     order: [
//       "router.post('/add_new_post', (req, res) => {",
//       "msg = '';\nif (req.session.loggedIn) {",
//       "var title = req.body.title;\nvar content = req.body.content;\nvar publish = req.body.publish;",
//       "db.query(",
//       "'select id from users where email = ?  ',",
//       "[req.session.email],\n(error, results, fields) => {",
//       "if (error) ",
//       "res.render('challenges/error');",
//       "else {\nvar user_id = results[0].id;\nvar published;",
//       "if (publish == 'true') published = 1;",
//       "else published = 0;",
//       "db.query(\n'insert into posts (title,content,user_id,published) values (?,?,?,?)  ',",
//       "[title, content, user_id, published],\n(err, results, fields) => {",
//       "if (err) \nres.render('challenges/error');",
//       "else {\nmsg = 'Blog Created Successfully';",
//       "res.redirect('/');",
//       "}\n}\n);\n}",
//       "}\n);\n} else ",
//       "res.redirect('login');",
//       "});",
//     ],
//     code: [
//       "db.query(\n'insert into posts (title,content,user_id,published) values (?,?,?,?)  ',",
//       "else {\nvar user_id = results[0].id;\nvar published;",
//       "res.redirect('login');",
//       "'select id from users where email = ?  ',",
//       "}\n);\n} else ",
//       "if (err) \nres.render('challenges/error');",
//       "if (publish == 'true') published = 1;",
//       "[title, content, user_id, published],\n(err, results, fields) => {",
//       "if (error) ",
//       "[req.session.email],\n(error, results, fields) => {",
//       "});",
//       "msg = '';\nif (req.session.loggedIn) {",
//       "else published = 0;",
//       "res.redirect('/');",
//       "res.render('challenges/error');",
//       "else {\nmsg = 'Blog Created Successfully';",
//       "var title = req.body.title;\nvar content = req.body.content;\nvar publish = req.body.publish;",
//       "}\n}\n);\n}",
//       "db.query(",
//       "router.post('/add_new_post', (req, res) => {",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 20,
//     day: 1,
//     order: [
//       "useEffect(() => {",
//       "if (localStorage.getItem('userInfo')) {\nhistory.push('/');",
//       "}\n}, [history]);",
//       "const loginHandler = async (e) => {",
//       "e.preventDefault();",
//       " const config = {",
//       " header: {",
//       " 'Content-Type': 'application/json',\n}",
//       " };",
//       "try {",
//       "const { data } = await axios.post(\n'/api/auth/login',\n{ email, password },\nconfig\n);",
//       "localStorage.setItem('userInfo', JSON.stringify(data));",
//       " const userinfo = localStorage.getItem('userInfo');",
//       " if (userinfo) {\nhistory.push('/game');\n}",
//       "} catch (error) {",
//       "setError(error.response.data.error);",
//       "setTimeout(() => {\nsetError('');\n}, 5000);",
//       "}\n};",
//     ],
//     code: [
//       " header: {",
//       "}\n}, [history]);",
//       " if (userinfo) {\nhistory.push('/game');\n}",
//       "localStorage.setItem('userInfo', JSON.stringify(data));",
//       "setTimeout(() => {\nsetError('');\n}, 5000);",
//       "try {",
//       "const loginHandler = async (e) => {",
//       "e.preventDefault();",
//       "} catch (error) {",
//       "useEffect(() => {",
//       "setError(error.response.data.error);",
//       "}\n};",
//       "const { data } = await axios.post(\n'/api/auth/login',\n{ email, password },\nconfig\n);",
//       " const config = {",
//       " const userinfo = localStorage.getItem('userInfo');",
//       " };",
//       "if (localStorage.getItem('userInfo')) {\nhistory.push('/');",
//       " 'Content-Type': 'application/json',\n}",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 21,
//     day: 1,
//     order: [
//       "void deleteNode(Node* &root, int key) \n {",
//       "if (root == nullptr) { \n return; \n }",
//       " if (key < root->data) {\n deleteNode(root->left, key);\n}",
//       "else if (key > root->data) {\ndeleteNode(root->right, key);\n}",
//       "else {",
//       " if (root->left == nullptr && root->right == nullptr)\n{\ndelete root;\nroot = nullptr;\n}",
//       " else if (root->left && root->right)\n{",
//       "if (root->left->priority < root->right->priority)\n{\nrotateLeft(root);\ndeleteNode(root->left, key);\n}",
//       " else {\nrotateRight(root);\ndeleteNode(root->right, key);\n}\n}",
//       "else {\nNode* child = (root->left)? root->left: root->right;",
//       " Node* curr = root;\nroot = child;",
//       "  delete curr;\n}\n}",
//       "}",
//     ],
//     code: [
//       "else if (key > root->data) {\ndeleteNode(root->right, key);\n}",
//       " else {\nrotateRight(root);\ndeleteNode(root->right, key);\n}\n}",
//       "void deleteNode(Node* &root, int key) \n {",
//       "}",
//       " if (root->left == nullptr && root->right == nullptr)\n{\ndelete root;\nroot = nullptr;\n}",
//       "else {\nNode* child = (root->left)? root->left: root->right;",
//       " Node* curr = root;\nroot = child;",
//       "if (root->left->priority < root->right->priority)\n{\nrotateLeft(root);\ndeleteNode(root->left, key);\n}",
//       " else if (root->left && root->right)\n{",
//       "  delete curr;\n}\n}",
//       "else {",
//       " if (key < root->data) {\n deleteNode(root->left, key);\n}",
//       "if (root == nullptr) { \n return; \n }",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 22,
//     day: 1,
//     order: [
//       "while(*e != NULL) \n {",
//       "if(isalnum(*e))",
//       "printf('%c',*e); \n else if(*e == '(')",
//       "push(*e);",
//       "else if(*e == ')') \n {",
//       " while((x = pop()) != '(')",
//       "printf('%c', x);}",
//       "else \n {",
//       "while(priority(stack[top]) >= priority(*e))",
//       "printf('%c',pop());",
//       "push(*e); \n }",
//       "e++; \n  }",
//     ],
//     code: [
//       "if(isalnum(*e))",
//       "push(*e); \n }",
//       "else \n {",
//       "push(*e);",
//       "else if(*e == ')') \n {",
//       "e++; \n  }",
//       " while((x = pop()) != '(')",
//       "printf('%c', x);}",
//       "while(*e != NULL) \n {",
//       "printf('%c',pop());",
//       "while(priority(stack[top]) >= priority(*e))",
//       "printf('%c',*e); \n else if(*e == '(')",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 23,
//     day: 1,
//     order: [
//       "node* function1(node* root)\n{",
//       "if (root == NULL)",
//       "return root;",
//       "if (root->left != NULL) {",
//       "node* left = function1(root->left);",
//       "for (; left->right != NULL; left = left->right);",
//       "left->right = root;",
//       " root->left = left;",
//       "}\nif (root->right != NULL) {",
//       "node* right = function1(root->right);",
//       "for (; right->left != NULL; right = right->left);",
//       "right->left = root;",
//       "root->right = right;",
//       "}\nreturn root;\n}",
//       "node* function(node* root)",
//       "{\nif (root == NULL)\nreturn root;",
//       "root = function1(root);",
//       "while (root->left != NULL)",
//       " root = root->left;",
//       "return (root);\n}",
//     ],
//     code: [
//       "}\nreturn root;\n}",
//       "node* function(node* root)",
//       "return root;",
//       "root->right = right;",
//       "node* left = function1(root->left);",
//       "while (root->left != NULL)",
//       "node* right = function1(root->right);",
//       " root->left = left;",
//       "right->left = root;",
//       "}\nif (root->right != NULL) {",
//       "if (root == NULL)",
//       "return (root);\n}",
//       "root = function1(root);",
//       "node* function1(node* root)\n{",
//       "for (; left->right != NULL; left = left->right);",
//       "{\nif (root == NULL)\nreturn root;",
//       "if (root->left != NULL) {",
//       "left->right = root;",
//       "for (; right->left != NULL; right = right->left);",
//       " root = root->left;",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 24,
//     day: 1,
//     order: [
//       "int findMax(vector<vector<int>> const &M) \n {",
//       "if (M.size() == 0)",
//       "return 0;",
//       "int n = M.size(); \n int K[n][n]; \n int max = M[n-1][n-1];",
//       "K[n-1][n-1] = M[n-1][n-1];",
//       "for (int j = n-2; j >= 0; j--) \n {",
//       "if (M[n-1][j] > max) { \n max = M[n-1][j]; \n }",
//       "K[n-1][j] = max; \n }",
//       "max = M[n-1][n-1];",
//       "for (int i = n-2; i >= 0; i--) \n {",
//       "if (M[i][n-1] > max) { \n max = M[i][n-1]; \n }",
//       "K[i][n-1] = max; \n }",
//       "max = INT_MIN;",
//       "for (int a = n-2; a >= 0; a--) \n {",
//       "for (int b = n-2; b >= 0; b--) \n {",
//       "if (K[a+1][b+1] - M[a][b] > max)",
//       "max = K[a+1][b+1] - M[a][b];",
//       "K[a][b] = std::max(M[a][b], std::max(K[a][b+1], K[a+1][b])); \n } \n }",
//       "return max; \n }",
//     ],
//     code: [
//       "for (int b = n-2; b >= 0; b--) \n {",
//       "K[i][n-1] = max; \n }",
//       "for (int a = n-2; a >= 0; a--) \n {",
//       "for (int j = n-2; j >= 0; j--) \n {",
//       "max = INT_MIN;",
//       "max = K[a+1][b+1] - M[a][b];",
//       "return 0;",
//       "int n = M.size(); \n int K[n][n]; \n int max = M[n-1][n-1];",
//       "if (M.size() == 0)",
//       "int findMax(vector<vector<int>> const &M) \n {",
//       "if (M[i][n-1] > max) { \n max = M[i][n-1]; \n }",
//       "if (K[a+1][b+1] - M[a][b] > max)",
//       "K[n-1][j] = max; \n }",
//       "if (M[n-1][j] > max) { \n max = M[n-1][j]; \n }",
//       "return max; \n }",
//       "for (int i = n-2; i >= 0; i--) \n {",
//       "K[a][b] = std::max(M[a][b], std::max(K[a][b+1], K[a+1][b])); \n } \n }",
//       "K[n-1][n-1] = M[n-1][n-1];",
//       "max = M[n-1][n-1];",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 25,
//     day: 1,
//     order: [
//       "class Ques {",
//       "public:",
//       "bool function(string s) {",
//       "vector<vector<int>>p(2001, vector<int>(2001,0));",
//       "for(int i=0;i<s.size();i++){",
//       "string s1 = s.substr(i,1); \n p[i][i] = 1; \n int l=i-1, r = i+1;",
//       "while(l>=0 &&  r<s.size() && s[l]==s[r]){",
//       "p[l][r] = 1;",
//       "l--; \n r++; \n }",
//       "int left = i, right = i+1;\n while(left>=0 && right<s.size() && s[left]==s[right]){",
//       "p[left][right] = 1;",
//       "left--; right++; \n } \n }",
//       "int n = s.size(); \n for(int i=0;i<n-2;i++){",
//       "for(int j=i+1;j<n-1;j++)",
//       "if(p[0][i]==1 && p[i+1][j]==1 && p[j+1][n-1]==1) ",
//       "return true; \n }",
//       "return false; \n }",
//       "};",
//     ],
//     code: [
//       "left--; right++; \n } \n }",
//       "while(l>=0 &&  r<s.size() && s[l]==s[r]){",
//       "for(int i=0;i<s.size();i++){",
//       "int n = s.size(); \n for(int i=0;i<n-2;i++){",
//       "vector<vector<int>>p(2001, vector<int>(2001,0));",
//       "p[left][right] = 1;",
//       "l--; \n r++; \n }",
//       "class Ques {",
//       "public:",
//       "return true; \n }",
//       "string s1 = s.substr(i,1); \n p[i][i] = 1; \n int l=i-1, r = i+1;",
//       "if(p[0][i]==1 && p[i+1][j]==1 && p[j+1][n-1]==1) ",
//       "return false; \n }",
//       "bool function(string s) {",
//       "};",
//       "p[l][r] = 1;",
//       "for(int j=i+1;j<n-1;j++)",
//       "int left = i, right = i+1;\n while(left>=0 && right<s.size() && s[left]==s[right]){",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 26,
//     day: 1,
//     order: [
//       "vector<int> DIR = {0, 1, 0, -1, 0};",
//       "int function(vector<vector<int>>& grid) {",
//       "int m = grid.size(), \n n = grid[0].size(), \n count=-1, \n f=0; \n queue<pair<int, int>> q;",
//       "for (int r = 0; r < m; ++r) {",
//       "for (int c = 0; c < n; ++c) {",
//       "if (grid[r][c] == 2)",
//       "q.emplace(r, c);",
//       "else if(grid[r][c] == 1)",
//       "f++; \n } \n }",
//       "while (!q.empty()) {",
//       "int sz=q.size();",
//       "while(sz--) {",
//       "queue<pair<int, int>> que;",
//       "auto [r, c] = q.front(); q.pop();",
//       "for (int i = 0; i < 4; ++i) {",
//       "int nr = r + DIR[i], nc = c + DIR[i+1];",
//       "if (nr < 0 || nr == m || nc < 0 || nc == n || grid[nr][nc] != 1)",
//       "continue;",
//       "grid[nr][nc] = grid[r][c];",
//       "q.emplace(nr, nc);",
//       "f--; \n } \n }",
//       "count++; \n }",
//       "if(f>0)",
//       "return -1;",
//       "return max(0,count); \n }",
//     ],
//     code: [
//       "queue<pair<int, int>> que;",
//       "auto [r, c] = q.front(); q.pop();",
//       "grid[nr][nc] = grid[r][c];",
//       "q.emplace(nr, nc);",
//       "int sz=q.size();",
//       "continue;",
//       "f++; \n } \n }",
//       "for (int i = 0; i < 4; ++i) {",
//       "if (grid[r][c] == 2)",
//       "return -1;",
//       "for (int r = 0; r < m; ++r) {",
//       "if (nr < 0 || nr == m || nc < 0 || nc == n || grid[nr][nc] != 1)",
//       "q.emplace(r, c);",
//       "return max(0,count); \n }",
//       "for (int c = 0; c < n; ++c) {",
//       "while(sz--) {",
//       "int nr = r + DIR[i], nc = c + DIR[i+1];",
//       "if(f>0)",
//       "vector<int> DIR = {0, 1, 0, -1, 0};",
//       "while (!q.empty()) {",
//       "int m = grid.size(), \n n = grid[0].size(), \n count=-1, \n f=0; \n queue<pair<int, int>> q;",
//       "int function(vector<vector<int>>& grid) {",
//       "count++; \n }",
//       "f--; \n } \n }",
//       "else if(grid[r][c] == 1)",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 27,
//     day: 1,
//     order: [
//       "class Ques {",
//       "public:",
//       "std::vector<int> function(std::vector<int>& encoded) { \n std::vector<int> perm(n, 0);",
//       "const int n = encoded.size() + 1; \n int x = 0, e=0",
//       "for ( int i = 1; i <= n; ++i )",
//       "x ^= i;\nfor ( int i = 1; i < encoded.size(); i += 2 )",
//       "e ^= encoded[i];",
//       "int po = x ^ e;",
//       "perm[0] = po;",
//       "for ( int i = 1; i < n; ++i )",
//       "perm[i] = perm[i-1] ^ encoded[i-1];",
//       "return perm; \n }",
//       "};",
//     ],
//     code: [
//       "return perm; \n }",
//       "x ^= i;\nfor ( int i = 1; i < encoded.size(); i += 2 )",
//       "for ( int i = 1; i <= n; ++i )",
//       "perm[i] = perm[i-1] ^ encoded[i-1];",
//       "public:",
//       "e ^= encoded[i];",
//       "class Ques {",
//       "int po = x ^ e;",
//       "const int n = encoded.size() + 1; \n int x = 0, e=0",
//       "perm[0] = po;",
//       "for ( int i = 1; i < n; ++i )",
//       "};",
//       "std::vector<int> function(std::vector<int>& encoded) { \n std::vector<int> perm(n, 0);",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 28,
//     day: 1,
//     order: [
//       "pair<int, int> findMinimumRange(vector<vector<int>> lists) \n {",
//       "if (lists.size() == 0)",
//       "return {-1, -1};",
//       "int M = lists.size(); \n int high = INT_MIN; \n pair<int, int> p = { 0, INT_MAX }; \npriority_queue<Node, vector<Node>, comp> pq;",
//       "for (int i = 0; i < M; i++)\n {",
//       "if (lists[i].size() == 0)\nreturn {-1, -1};",
//       "pq.push({lists[i][0], i, 0});",
//       "high = max(high, lists[i][0]); \n }",
//       "while (true) \n {",
//       "int low = pq.top().value; \n int i = pq.top().list_num; \n int j = pq.top().index;",
//       "pq.pop();",
//       "if (high - low < p.second - p.first) ",
//       "p = {low, high};",
//       "if (j == lists[i].size() - 1)",
//       "return p;",
//       "pq.push({lists[i][j + 1], i, j + 1});",
//       "high = max(high, lists[i][j + 1]); \n } \n }",
//     ],
//     code: [
//       "return p;",
//       "for (int i = 0; i < M; i++)\n {",
//       "return {-1, -1};",
//       "if (lists[i].size() == 0)\nreturn {-1, -1};",
//       "while (true) \n {",
//       "high = max(high, lists[i][j + 1]); \n } \n }",
//       "int low = pq.top().value; \n int i = pq.top().list_num; \n int j = pq.top().index;",
//       "pair<int, int> findMinimumRange(vector<vector<int>> lists) \n {",
//       "if (lists.size() == 0)",
//       "pq.push({lists[i][0], i, 0});",
//       "pq.pop();",
//       "high = max(high, lists[i][0]); \n }",
//       "p = {low, high};",
//       "if (high - low < p.second - p.first) ",
//       "int M = lists.size(); \n int high = INT_MIN; \n pair<int, int> p = { 0, INT_MAX }; \npriority_queue<Node, vector<Node>, comp> pq;",
//       "if (j == lists[i].size() - 1)",
//       "pq.push({lists[i][j + 1], i, j + 1});",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 29,
//     day: 1,
//     order: [
//       "class Ques {",
//       "public:",
//       "vector<vector> dir={{-1,0},{1,0},{0,1},{0,-1}};",
//       "bool fn(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int a, int b) \n {",
//       "grid2[a][b]=0; \n bool res = true;",
//       "for(int i=0;i<4;i++) {",
//       "int x = a + dir[i][0]; \n int y = b + dir[i][1];",
//       "if(x>=0 && y>=0 && x< grid1.size() && y< grid1[0].size() && grid2[x][y]==1)",
//       "res&= fn(grid1, grid2, x, y); \n }",
//       "return res && (grid1[a][b]==1); \n } ",
//       "int function(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {",
//       "int n= grid1.size(), m= grid1[0].size(), count = 0;",
//       "for(int i=0;i<n;i++) \n {",
//       "for(int j=0;j<m;j++) \n {",
//       "if(grid2[i][j]==1)",
//       "count+= fn(grid1, grid2, i, j)?1:0; \n } \n }",
//       "return count; \n }",
//       "};",
//     ],
//     code: [
//       "int n= grid1.size(), m= grid1[0].size(), count = 0;",
//       "for(int i=0;i<4;i++) {",
//       "return res && (grid1[a][b]==1); \n } ",
//       "for(int i=0;i<n;i++) \n {",
//       "int x = a + dir[i][0]; \n int y = b + dir[i][1];",
//       "class Ques {",
//       "grid2[a][b]=0; \n bool res = true;",
//       "public:",
//       "if(grid2[i][j]==1)",
//       "};",
//       "bool fn(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int a, int b) \n {",
//       "return count; \n }",
//       "for(int j=0;j<m;j++) \n {",
//       "res&= fn(grid1, grid2, x, y); \n }",
//       "vector<vector> dir={{-1,0},{1,0},{0,1},{0,-1}};",
//       "int function(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {",
//       "if(x>=0 && y>=0 && x< grid1.size() && y< grid1[0].size() && grid2[x][y]==1)",
//       "count+= fn(grid1, grid2, i, j)?1:0; \n } \n }",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 30,
//     day: 1,
//     order: [
//       "class Ques {",
//       "public:",
//       "int mind(vector<vector<int>> &mat, int target){",
//       "int ind = 0, mn = 0;",
//       "for(int i = 0;i<mat[0].size();i++){",
//       "if(mat[target][i] > mn){",
//       "ind = i; \n mn = mat[target][i]; \n } \n }",
//       "return ind; \n }",
//       "int ch(vector<vector<int>> &nums, int mid, int target){",
//       "if(mid-1 < 0){",
//       "if(nums[mid][target]<nums[mid+1][target]) \n return 1;",
//       "else\n return 0; \n }",
//       "else if(mid+1>nums.size()-1){",
//       "if(nums[mid][target] > nums[mid-1][target]) \n return 0;",
//       "return -1; \n }",
//       "else{",
//       "if(nums[mid][target]>nums[mid+1][target] && nums[mid-1][target]< nums[mid][target]) \n return 0;",
//       "else if(nums[mid+1][target]>nums[mid-1][target]) \n return 1;",
//       "else \n return -1; \n } \n }",
//       "vector<int> function(vector<vector<int>>& mat) {\nint l = 0, h = mat.size(), ind = 0;",
//       "while(l<h){",
//       "int mid = (l+h)/2;",
//       "ind = mind(mat, mid);",
//       "int t = ch(mat,mid,ind);",
//       "if(t==0) \n return {mid,ind};",
//       "else if (t==1) \n l = mid+1;",
//       "else \n h = mid; \n }",
//       "return {l,ind}; \n }",
//       "};",
//     ],
//     code: [
//       "else if(nums[mid+1][target]>nums[mid-1][target]) \n return 1;",
//       "else \n return -1; \n } \n }",
//       "if(nums[mid][target]<nums[mid+1][target]) \n return 1;",
//       "};",
//       "int mind(vector<vector<int>> &mat, int target){",
//       "int t = ch(mat,mid,ind);",
//       "public:",
//       "int ind = 0, mn = 0;",
//       "else{",
//       "if(nums[mid][target] > nums[mid-1][target]) \n return 0;",
//       "else if (t==1) \n l = mid+1;",
//       "int ch(vector<vector<int>> &nums, int mid, int target){",
//       "for(int i = 0;i<mat[0].size();i++){",
//       "else\n return 0; \n }",
//       "else \n h = mid; \n }",
//       "if(mid-1 < 0){",
//       "while(l<h){",
//       "if(mat[target][i] > mn){",
//       "if(nums[mid][target]>nums[mid+1][target] && nums[mid-1][target]< nums[mid][target]) \n return 0;",
//       "class Ques {",
//       "return {l,ind}; \n }",
//       "ind = i; \n mn = mat[target][i]; \n } \n }",
//       "int mid = (l+h)/2;",
//       "return -1; \n }",
//       "if(t==0) \n return {mid,ind};",
//       "else if(mid+1>nums.size()-1){",
//       "return ind; \n }",
//       "ind = mind(mat, mid);",
//       "vector<int> function(vector<vector<int>>& mat) {\nint l = 0, h = mat.size(), ind = 0;",
//     ],
//   },
// ]);

// // // //second day

// Question.insertMany([
//   {
//     level: 1,
//     day: 2,
//     order: [
//       "echo 'Total marks : $sum '",
//       "echo 'Grade : '",
//       "if [ $sum -gt 200 ]; then",
//       "if [ $sum -gt 250 ]; then",
//       "if [ $sum -gt 300 ]; then",
//       "if [ $sum -gt 350 ]; then",
//       "if [ $sum -gt 400 ]; then",
//       "if [ $sum -gt 450 ]; then",
//       "echo 'S'",
//       "else",
//       "echo 'A'\nfi",
//       "else\necho 'B'",
//       "fi\nelse",
//       "echo 'C'",
//       "fi\nelse\necho 'D'",
//       "fi\nelse\necho 'E'",
//       "fi\nelse\necho 'F'",
//       "fi",
//     ],
//     code: [
//       "fi",
//       "if [ $sum -gt 400 ]; then",
//       "else\necho 'B'",
//       "echo 'Total marks : $sum '",
//       "if [ $sum -gt 300 ]; then",
//       "fi\nelse\necho 'F'",
//       "if [ $sum -gt 350 ]; then",
//       "if [ $sum -gt 200 ]; then",
//       "if [ $sum -gt 250 ]; then",
//       "echo 'Grade : '",
//       "echo 'S'",
//       "fi\nelse\necho 'D'",
//       "if [ $sum -gt 450 ]; then",
//       "echo 'A'\nfi",
//       "echo 'C'",
//       "fi\nelse",
//       "fi\nelse\necho 'E'",
//       "else",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 2,
//     day: 2,
//     order: [
//       "def func(X, Y):",
//       "if len(X) != len(Y):",
//       "return False",
//       "dict = {} \n s = set()",
//       "for i in range(len(X)):",
//       "x = X[i] \n y = Y[i]",
//       "if x in dict:",
//       "if dict[x] != y:",
//       "return False",
//       "else:",
//       "if y in s:",
//       "return False",
//       "dict[x] = y \n s.add(y)",
//       "return True",
//     ],
//     code: [
//       "def func(X, Y):",
//       "return True",
//       "if len(X) != len(Y):",
//       "x = X[i] \n y = Y[i]",
//       "for i in range(len(X)):",
//       "else:",
//       "return False",
//       "if y in s:",
//       "dict[x] = y \n s.add(y)",
//       "return False",
//       "return False",
//       "dict = {} \n s = set()",
//       "if x in dict:",
//       "if dict[x] != y:",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 3,
//     day: 2,
//     order: [
//       "export default function App() {",
//       "const { register, errors, handleSubmit } = useForm();",
//       "const onSubmit = (data) => {",
//       "alert(JSON.stringify(data));",
//       "};",
//       "return (",
//       " <form onSubmit={handleSubmit(onSubmit)}>",
//       "<FormSection1 register={register} />",
//       " <input type='submit' />",
//       "  </form>",
//       " );\n }",
//     ],
//     code: [
//       "const { register, errors, handleSubmit } = useForm();",
//       "alert(JSON.stringify(data));",
//       "  </form>",
//       " <form onSubmit={handleSubmit(onSubmit)}>",
//       "<FormSection1 register={register} />",
//       " <input type='submit' />",
//       "return (",
//       "const onSubmit = (data) => {",
//       "export default function App() {",
//       "};",
//       " );\n }",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 4,
//     day: 2,
//     order: [
//       "SELECT",
//       "d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary",
//       "FROM",
//       "Employee e1",
//       "JOIN",
//       "Department d ON e1.DepartmentId = d.Id",
//       "WHERE",
//       "3 > (SELECT",
//       "COUNT(DISTINCT e2.Salary)",
//       "FROM",
//       "Employee e2",
//       "WHERE",
//       "e2.Salary > e1.Salary",
//       "AND e1.DepartmentId = e2.DepartmentId",
//       ")",
//       ";",
//     ],
//     code: [
//       "AND e1.DepartmentId = e2.DepartmentId",
//       "WHERE",
//       ";",
//       "FROM",
//       "Employee e1",
//       "COUNT(DISTINCT e2.Salary)",
//       "3 > (SELECT",
//       "SELECT",
//       ")",
//       "e2.Salary > e1.Salary",
//       "Employee e2",
//       "FROM",
//       "d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary",
//       "WHERE",
//       "JOIN",
//       "Department d ON e1.DepartmentId = d.Id",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 5,
//     day: 2,
//     order: [
//       "exports.protect = async (req, res, next) => {",
//       "let token;",
//       "if (\nreq.headers.authorization &&\nreq.headers.authorization.startsWith('Bearer')\n)",
//       "token = req.headers.authorization.split(' ')[1];",
//       "if (!token) ",
//       "return next(new ErrorResponse('Not authorized to access this route', 401));",
//       " try {",
//       " const decoded = jwt.verify(token, process.env.JWT_SECRET);",
//       "const user = await User.findById(decoded.id);",
//       "if (!user) \nreturn next(new ErrorResponse('No user found with this id', 404));",
//       "req.user = user;\nnext();",
//       " } catch (err) {",
//       " return next(new ErrorResponse('Not authorized to access this router', 401));\n}",
//       "};",
//     ],
//     code: [
//       " const decoded = jwt.verify(token, process.env.JWT_SECRET);",
//       " } catch (err) {",
//       " return next(new ErrorResponse('Not authorized to access this router', 401));\n}",
//       "return next(new ErrorResponse('Not authorized to access this route', 401));",
//       "const user = await User.findById(decoded.id);",
//       "exports.protect = async (req, res, next) => {",
//       "if (!user) \nreturn next(new ErrorResponse('No user found with this id', 404));",
//       " try {",
//       "};",
//       "let token;",
//       "if (!token) ",
//       "if (\nreq.headers.authorization &&\nreq.headers.authorization.startsWith('Bearer')\n)",
//       "req.user = user;\nnext();",
//       "token = req.headers.authorization.split(' ')[1];",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 6,
//     day: 2,
//     order: [
//       "const AuthState = props => {",
//       " const initialState = {\ntoken: localStorage.getItem('token'),\nisAuthenticated: null,\nloading: true,\nuser: null,\nerror: null\n};",
//       "const [state, dispatch] = useReducer(authReducer, initialState);",
//       "const loadUser = async () => {",
//       "setAuthToken(localStorage.token);",
//       "  try {",
//       "const res = await axios.get('/api/auth');",
//       "dispatch({\ntype: USER_LOADED,\npayload: res.data\n});",
//       " } catch (err) {",
//       "dispatch({ type: AUTH_ERROR });",
//       "}\n};",
//     ],
//     code: [
//       "const res = await axios.get('/api/auth');",
//       "}\n};",
//       "const loadUser = async () => {",
//       " } catch (err) {",
//       "dispatch({ type: AUTH_ERROR });",
//       "  try {",
//       " const initialState = {\ntoken: localStorage.getItem('token'),\nisAuthenticated: null,\nloading: true,\nuser: null,\nerror: null\n};",
//       "const AuthState = props => {",
//       "setAuthToken(localStorage.token);",
//       "dispatch({\ntype: USER_LOADED,\npayload: res.data\n});",
//       "const [state, dispatch] = useReducer(authReducer, initialState);",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 7,
//     day: 2,
//     order: [
//       "int max = n - 1;\nint min = 0;\nint i;\nint* s = new int[n];\n  int* g = new int[n];",
//       " s[0] = -1;\n  g[n - 1] = -1;",
//       "for (i = 1; i < n; i++) {\nif (arr[i] <= arr[min]) {",
//       "min = i;\ns[i] = -1;",
//       "}\nelse\ns[i] = min;",
//       "}\nfor (i = n - 2; i >= 0; i--) {\nif (arr[i] >= arr[max]) {",
//       " max = i;\ng[i] = -1;\n}",
//       "else\ng[i] = max;\n}",
//       "for (i = 0; i < n; i++) {",
//       "if (s[i] != -1 && g[i] != -1) {",
//       "cout << arr[s[i]]<< endl << arr[i] << endl<< arr[g[i]];\nreturn;\n}\n}",
//     ],
//     code: [
//       " max = i;\ng[i] = -1;\n}",
//       "if (s[i] != -1 && g[i] != -1) {",
//       "}\nfor (i = n - 2; i >= 0; i--) {\nif (arr[i] >= arr[max]) {",
//       "}\nelse\ns[i] = min;",
//       "for (i = 0; i < n; i++) {",
//       "int max = n - 1;\nint min = 0;\nint i;\nint* s = new int[n];\n  int* g = new int[n];",
//       "min = i;\ns[i] = -1;",
//       "cout << arr[s[i]]<< endl << arr[i] << endl<< arr[g[i]];\nreturn;\n}\n}",
//       "for (i = 1; i < n; i++) {\nif (arr[i] <= arr[min]) {",
//       "else\ng[i] = max;\n}",
//       " s[0] = -1;\n  g[n - 1] = -1;",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 8,
//     day: 2,
//     order: [
//       "router.post('/add', function(req, res, next) {",
//       "var name = req.body.name; \n var errors = req.validationErrors();",
//       "req.checkBody('name','Name field is required').notEmpty();",
//       "if(errors)",
//       "res.render('addpost',{\n'errors': errors\n});",
//       " else {\nvar categories = db.get('categories');",
//       "categories.insert({\n'name': name,\n}, function(err, post){",
//       "if(err)",
//       "res.send(err);",
//       "else {",
//       "req.flash('success','Category Added');",
//       "res.location('/');",
//       "}\n});\n}",
//       "});",
//     ],
//     code: [
//       "router.post('/add', function(req, res, next) {",
//       "var name = req.body.name; \n var errors = req.validationErrors();",
//       "req.flash('success','Category Added');",
//       "}\n});\n}",
//       "req.checkBody('name','Name field is required').notEmpty();",
//       "res.send(err);",
//       "});",
//       "if(errors)",
//       "categories.insert({\n'name': name,\n}, function(err, post){",
//       "res.location('/');",
//       "else {",
//       "res.render('addpost',{\n'errors': errors\n});",
//       "if(err)",
//       " else {\nvar categories = db.get('categories');",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 9,
//     day: 2,
//     order: [
//       "def loginView(request):",
//       "if request.method == 'POST':",
//       "username = request.POST['username']\npassword = request.POST['password']",
//       "user = authenticate(request, username=username, password=password)",
//       "if user is not None and user.is_active:",
//       "auth.login(request, user)",
//       "if user.is_admin or user.is_superuser:",
//       "return redirect(' Admin dashboard')",
//       "elif user.is_librarian:",
//       "return redirect('librarian')",
//       "else:",
//       "return redirect('publisher')",
//       "else:\nmessages.info(request, 'Invalid username or password')",
//       "return redirect('home')",
//     ],
//     code: [
//       "if user is not None and user.is_active:",
//       "else:",
//       "username = request.POST['username']\npassword = request.POST['password']",
//       "else:\nmessages.info(request, 'Invalid username or password')",
//       "auth.login(request, user)",
//       "return redirect('publisher')",
//       "elif user.is_librarian:",
//       "user = authenticate(request, username=username, password=password)",
//       "def loginView(request):",
//       "return redirect('librarian')",
//       "if request.method == 'POST':",
//       "return redirect('home')",
//       "if user.is_admin or user.is_superuser:",
//       "return redirect(' Admin dashboard')",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 10,
//     day: 2,
//     order: [
//       "int function(int l, int r, int key, int ar[])\n{",
//       "if (r >= l) {",
//       "int mid1 = l + (r - l) /3 \n ;int mid2 = r - (r - l) / 3;",
//       "if (ar[mid1] == key) ",
//       " return mid1;",
//       "if (ar[mid2] == key) ",
//       "return mid2;",
//       "if (key < ar[mid1]) ",
//       "return function(l, mid1 - 1, key, ar);",
//       "else if (key > ar[mid2]) ",
//       "return function(mid2 + 1, r, key, ar);",
//       "else ",
//       " return function(mid1 + 1, mid2 - 1, key, ar);",
//       " }\nreturn -1;\n}",
//     ],
//     code: [
//       "else ",
//       " return mid1;",
//       " return function(mid1 + 1, mid2 - 1, key, ar);",
//       "return mid2;",
//       "return function(l, mid1 - 1, key, ar);",
//       "if (ar[mid1] == key) ",
//       "int function(int l, int r, int key, int ar[])\n{",
//       "else if (key > ar[mid2]) ",
//       "if (key < ar[mid1]) ",
//       "if (ar[mid2] == key) ",
//       " }\nreturn -1;\n}",
//       "return function(mid2 + 1, r, key, ar);",
//       "if (r >= l) {",
//       "int mid1 = l + (r - l) /3 \n ;int mid2 = r - (r - l) / 3;",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 11,
//     day: 2,
//     order: [
//       "return function (array, cmp) {",
//       "var gap, current;\ncmp = cmp || compare;",
//       "for (var k = 0; k < gaps.length; k += 1) {",
//       "gap = gaps[k]",
//       "for (var i = gap; i < array.length; i += gap) {",
//       "current = array[i];",
//       "for (var j = i;j >= gap && cmp(array[j - gap], current) > 0; j -= gap) {",
//       " array[j] = array[j - gap];\n}",
//       "array[j] = current;\n}",
//       "}",
//       "return array;\n};",
//     ],
//     code: [
//       "return function (array, cmp) {",
//       "}",
//       "for (var k = 0; k < gaps.length; k += 1) {",
//       " array[j] = array[j - gap];\n}",
//       "for (var j = i;j >= gap && cmp(array[j - gap], current) > 0; j -= gap) {",
//       "var gap, current;\ncmp = cmp || compare;",
//       "return array;\n};",
//       "gap = gaps[k]",
//       "array[j] = current;\n}",
//       "for (var i = gap; i < array.length; i += gap) {",
//       "current = array[i];",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 12,
//     day: 2,
//     order: [
//       "<div id='container'>",
//       "<div id='namesWrapper#1'>",
//       "<h2>ChatIO</h2>",
//       "<form id='usernameForm'>",
//       "<input type='text' size='35' id='username'>",
//       "<input type='submit' value='Submit'>",
//       "</form>\n</div>",
//       "<div id='chatWrapper#2'>",
//       "<div id='chatWindow'></div>\n<form id='messageForm'>",
//       "<input type='text' size='35' id='message' placeholder='Say Something...'>",
//       "<input type='submit' value='Submit'>\n</form>",
//       "</div>\n</div>",
//     ],
//     code: [
//       "<form id='usernameForm'>",
//       "</div>\n</div>",
//       "<div id='namesWrapper#1'>",
//       "<input type='text' size='35' id='message' placeholder='Say Something...'>",
//       "<div id='container'>",
//       "</form>\n</div>",
//       "<div id='chatWrapper#2'>",
//       "<input type='text' size='35' id='username'>",
//       "<input type='submit' value='Submit'>",
//       "<div id='chatWindow'></div>\n<form id='messageForm'>",
//       "<h2>ChatIO</h2>",
//       "<input type='submit' value='Submit'>\n</form>",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 13,
//     day: 2,
//     order: [
//       "class CodePazuru{",
//       "public:",
//       "void function1(long long a[], long long b[], int n, int m){",
//       "int gap = (n + m + 1) / 2;",
//       "while (gap) {",
//       "int i = 0, j = gap;",
//       "while (j < (n + m)) ",
//       "{ \n if (i < n && j < n) {",
//       "if (a[i] > a[j]) swap(a[i], a[j]); \n }",
//       "else if (i < n && j >= n) {",
//       "if (a[i] > b[j - n]) swap(a[i], b[j - n]); \n }",
//       "else{ ",
//       "if (b[i - n] > b[j - n]) swap(b[i - n], b[j - n]); \n }",
//       "++i; \n ++j; \n}",
//       "gap = gap < 2 ? 0 : (gap + 1) / 2; \n } \n } ",
//       "};",
//     ],
//     code: [
//       "if (a[i] > b[j - n]) swap(a[i], b[j - n]); \n }",
//       "void function1(long long a[], long long b[], int n, int m){",
//       "else{ ",
//       "int gap = (n + m + 1) / 2;",
//       "public:",
//       "class CodePazuru{",
//       "{ \n if (i < n && j < n) {",
//       "while (gap) {",
//       "++i; \n ++j; \n}",
//       "int i = 0, j = gap;",
//       "if (b[i - n] > b[j - n]) swap(b[i - n], b[j - n]); \n }",
//       "gap = gap < 2 ? 0 : (gap + 1) / 2; \n } \n } ",
//       "};",
//       "if (a[i] > a[j]) swap(a[i], a[j]); \n }",
//       "else if (i < n && j >= n) {",
//       "while (j < (n + m)) ",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 14,
//     day: 2,
//     order: [
//       "void function(vector<vector<int>> &mat)\n{",
//       " if (mat.size() == 0)\nreturn;",
//       "int top = 0, bottom = mat.size() - 1;\nint left = 0, right = mat[0].size() - 1;\nint prev = mat[0][0];",
//       "while (true)\n{\nif (left > right) \nbreak;",
//       " for (int i = left; i <= right; i++) \nswap(mat[top][i], prev);",
//       "top++;\nif (top > bottom) \nbreak;",
//       " for (int i = top; i <= bottom; i++) \nswap(mat[i][right], prev);",
//       "right--;",
//       "if (left > right) \nbreak;",
//       "for (int i = right; i >= left; i--) \nswap(mat[bottom][i], prev);",
//       "bottom--;",
//       "if (top > bottom) \nbreak;",
//       " for (int i = bottom; i >= top; i--) \nswap(mat[i][left], prev);",
//       "left++;",
//       "}",
//       "mat[0][0] = prev;\n}",
//     ],
//     code: [
//       " for (int i = bottom; i >= top; i--) \nswap(mat[i][left], prev);",
//       "bottom--;",
//       "for (int i = right; i >= left; i--) \nswap(mat[bottom][i], prev);",
//       "mat[0][0] = prev;\n}",
//       " if (mat.size() == 0)\nreturn;",
//       "if (top > bottom) \nbreak;",
//       " for (int i = left; i <= right; i++) \nswap(mat[top][i], prev);",
//       "right--;",
//       "int top = 0, bottom = mat.size() - 1;\nint left = 0, right = mat[0].size() - 1;\nint prev = mat[0][0];",
//       "void function(vector<vector<int>> &mat)\n{",
//       "left++;",
//       "if (left > right) \nbreak;",
//       "}",
//       " for (int i = top; i <= bottom; i++) \nswap(mat[i][right], prev);",
//       "top++;\nif (top > bottom) \nbreak;",
//       "while (true)\n{\nif (left > right) \nbreak;",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 15,
//     day: 2,
//     order: [
//       "bool function_1(Node* node) {",
//       " return node->left == nullptr && node->right == nullptr;\n}",
//       "void function_2(Node* root, Node* &head, Node* &prev)\n{",
//       "if (root == nullptr) \nreturn;",
//       " if (function_1(root))\n{",
//       "if (prev == nullptr) \nhead = root;",
//       "else \nprev->right = root;",
//       "prev = root;\n}",
//       "function_2(root->left, head, prev);",
//       " function_2(root->right, head, prev);\n}",
//       "bool function_3(Node* x, Node* y)\n{",
//       " Node* first = nullptr;",
//       "Node* prev = nullptr;\nNode* second = nullptr;",
//       "function_2(x, first, prev);",
//       "prev = nullptr;",
//       " function_3(y, second, prev);",
//       " while (first && second && first->key == second->key)\n{",
//       "first = first->right;\nsecond = second->right;\n}",
//       "return !first && !second;",
//       "}",
//     ],
//     code: [
//       "bool function_1(Node* node) {",
//       " return node->left == nullptr && node->right == nullptr;\n}",
//       "if (prev == nullptr) \nhead = root;",
//       "function_2(x, first, prev);",
//       " Node* first = nullptr;",
//       "function_2(root->left, head, prev);",
//       "else \nprev->right = root;",
//       "}",
//       "prev = nullptr;",
//       " while (first && second && first->key == second->key)\n{",
//       "if (root == nullptr) \nreturn;",
//       "return !first && !second;",
//       "prev = root;\n}",
//       "Node* prev = nullptr;\nNode* second = nullptr;",
//       "void function_2(Node* root, Node* &head, Node* &prev)\n{",
//       " if (function_1(root))\n{",
//       " function_3(y, second, prev);",
//       "bool function_3(Node* x, Node* y)\n{",
//       "first = first->right;\nsecond = second->right;\n}",
//       " function_2(root->right, head, prev);\n}",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 16,
//     day: 2,
//     order: [
//       "Node* function_1(bool mat[][N]){",
//       "multimap<int, int> multimap; \n Node* node[N]; \n int row; \n bool parent[N] = false;",
//       "for (int i = 0; i < N; i++) \n { \n int sum = 0;",
//       "for (int j = 0; j < N; j++)",
//       "sum += (int)mat[i][j];",
//       "multimap.insert({ sum, i }); \n } \n for (int i = 0; i < N; i++) {",
//       "parent[i] = false; \n }",
//       "for (auto it: multimap){",
//       "row = it.second;",
//       "node[row] = new Node(row);",
//       " if (it.first == 0) \n continue;",
//       "for (int i = 0; i < N; i++){",
//       "if (parent[i] == false && mat[row][i]){",
//       "if (node[row]->left == nullptr) \n node[row]->left = node[i];",
//       "else \n node[row]->right = node[i];",
//       "parent[i] = true; \n }",
//       "} \n } \n return node[row]; \n }",
//     ],
//     code: [
//       "Node* function_1(bool mat[][N]){",
//       "row = it.second;",
//       "if (node[row]->left == nullptr) \n node[row]->left = node[i];",
//       " if (it.first == 0) \n continue;",
//       "for (auto it: multimap){",
//       "node[row] = new Node(row);",
//       "for (int i = 0; i < N; i++) \n { \n int sum = 0;",
//       "parent[i] = true; \n }",
//       "sum += (int)mat[i][j];",
//       "else \n node[row]->right = node[i];",
//       "if (parent[i] == false && mat[row][i]){",
//       "for (int j = 0; j < N; j++)",
//       "parent[i] = false; \n }",
//       "for (int i = 0; i < N; i++){",
//       "multimap<int, int> multimap; \n Node* node[N]; \n int row; \n bool parent[N] = false;",
//       "} \n } \n return node[row]; \n }",
//       "multimap.insert({ sum, i }); \n } \n for (int i = 0; i < N; i++) {",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 17,
//     day: 2,
//     order: [
//       "class Ques {",
//       "public:",
//       "int function(int n) {",
//       "vector<vector<int>> dp(3,vector<int>(n+1,0));",
//       "for(int i=1;i<=2;i++){",
//       "for(int j=1;j<=n;j++){",
//       "if(i==1) \n dp[i][j] = j;",
//       "else if(j==1) \n dp[i][j] =1;",
//       "else{",
//       "int mn = INT_MAX;",
//       "for(int mj=j-1,mi=0;mj>=0;mj--,mi++){",
//       "int v1 = dp[i][mj]; \n int v2 = dp[i-1][mi]; \n int mx = max(v1,v2);",
//       "mn = min(mn,mx); \n }",
//       "dp[i][j] = 1 + mn; \n } \n } \n }",
//       "return dp[2][n]; \n ",
//       "};",
//     ],
//     code: [
//       "for(int j=1;j<=n;j++){",
//       "int mn = INT_MAX;",
//       "dp[i][j] = 1 + mn; \n } \n } \n }",
//       "class Ques {",
//       "if(i==1) \n dp[i][j] = j;",
//       "return dp[2][n]; \n ",
//       "};",
//       "else if(j==1) \n dp[i][j] =1;",
//       "else{",
//       "for(int i=1;i<=2;i++){",
//       "mn = min(mn,mx); \n }",
//       "for(int mj=j-1,mi=0;mj>=0;mj--,mi++){",
//       "int function(int n) {",
//       "public:",
//       "int v1 = dp[i][mj]; \n int v2 = dp[i-1][mi]; \n int mx = max(v1,v2);",
//       "vector<vector<int>> dp(3,vector<int>(n+1,0));",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 18,
//     day: 2,
//     order: [
//       "int function(int arr[], int n)\n{",
//       "int m,count=0;",
//       "for(int i=0;i<n;i++){",
//       "if(i==0){",
//       "m=arr[i];\ncount=1;",
//       "}\nelse if (m==arr[i]){\ncount++; \n}",
//       "else",
//       "count--;",
//       "}\ncount = 0;",
//       "for (int i = 0; i < n; i++) {\nif (arr[i] == m) ",
//       "count++;\n}",
//       "if (count > n / 2)",
//       "return m;",
//       "else\nreturn -1;\n}",
//     ],
//     code: [
//       "if(i==0){",
//       "count--;",
//       "else\nreturn -1;\n}",
//       "for (int i = 0; i < n; i++) {\nif (arr[i] == m) ",
//       "m=arr[i];\ncount=1;",
//       "count++;\n}",
//       "int function(int arr[], int n)\n{",
//       "if (count > n / 2)",
//       "return m;",
//       "}\ncount = 0;",
//       "else",
//       "for(int i=0;i<n;i++){",
//       "int m,count=0;",
//       "}\nelse if (m==arr[i]){\ncount++; \n}",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 19,
//     day: 2,
//     order: [
//       "class Solution {",
//       "public:",
//       " double myPow(double x, int n) {",
//       "double cur = x, res = 1;\nunsigned int pow;",
//       "if(x == 0)",
//       "return 0;",
//       "if(n < 0){",
//       "cur = 1 / x;\npow = (unsigned int)(-(n + 1)) + 1;",
//       "}else if(n == 0)",
//       "return 1;",
//       "else",
//       " pow = n;",
//       "while(pow != 0){",
//       "if(1&pow) res *= cur;",
//       "pow = pow >> 1;\ncur = cur * cur;",
//       "}\nreturn res;\n",
//       "}",
//       "};",
//     ],
//     code: [
//       "while(pow != 0){",
//       "}\nreturn res;\n",
//       "}",
//       "class Solution {",
//       "public:",
//       " double myPow(double x, int n) {",
//       "return 1;",
//       "cur = 1 / x;\npow = (unsigned int)(-(n + 1)) + 1;",
//       " pow = n;",
//       "};",
//       "}else if(n == 0)",
//       "if(n < 0){",
//       "if(1&pow) res *= cur;",
//       "double cur = x, res = 1;\nunsigned int pow;",
//       "pow = pow >> 1;\ncur = cur * cur;",
//       "else",
//       "return 0;",
//       "if(x == 0)",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 20,
//     day: 2,
//     order: [
//       "func function(n uint, fp float64) *c {",
//       "b := uint(4)",
//       "f := fingerprintLength(b, fp)",
//       "m := nextPower(n / f * 8)",
//       "buckets := make([]bucket, m)",
//       "for i := uint(0); i < m; i++ {",
//       "buckets[i] = make(bucket, b)",
//       "}\nreturn &c{",
//       "buckets: buckets,\nm:       m,\nb: b,\nf:   f\nn:       n,",
//       "}\n}",
//     ],
//     code: [
//       "buckets := make([]bucket, m)",
//       "}\n}",
//       "}\nreturn &c{",
//       "f := fingerprintLength(b, fp)",
//       "func function(n uint, fp float64) *c {",
//       "b := uint(4)",
//       "m := nextPower(n / f * 8)",
//       "for i := uint(0); i < m; i++ {",
//       "buckets[i] = make(bucket, b)",
//       "buckets: buckets,\nm:       m,\nb: b,\nf:   f\nn:       n,",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 21,
//     day: 2,
//     order: [
//       "class Ques {",
//       "public:",
//       "int function(vector<vector<int>>& grid) {",
//       "int m = grid.size(), n = grid[0].size(), ans =0; \n vector<vector<int> > dp(m, vector<int>(n, INT_MAX)); \n  int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};",
//       "queue<vector<int> > q;",
//       "for(int i=0; i<m; ++i) {",
//       "for(int j=0; j<n; ++j) {",
//       "if(grid[i][j] == 1) {",
//       "dp[i][j] = 0; \n q.push({i, j, 0}); \n } \n } \n",
//       "while(!q.empty()) {",
//       "auto p = q.front();",
//       "q.pop();",
//       "for(int k=0; k<4; ++k) {",
//       "int nx = p[0] + dx[k], ny = p[1] + dy[k], ndis = p[2] + 1;",
//       "if(nx < 0 || nx >= m || ny < 0 || ny >= n) \n continue; \n if(ndis < dp[nx][ny]) {",
//       "dp[nx][ny] = ndis;",
//       "q.push({nx, ny, ndis});",
//       "ans = max(ans, ndis); \n } \n } \n }",
//       "return ans == 0 ? -1 : ans; \n }",
//       "};",
//     ],
//     code: [
//       "q.pop();",
//       "return ans == 0 ? -1 : ans; \n }",
//       "q.push({nx, ny, ndis});",
//       "ans = max(ans, ndis); \n } \n } \n }",
//       "for(int i=0; i<m; ++i) {",
//       "if(grid[i][j] == 1) {",
//       "while(!q.empty()) {",
//       "for(int j=0; j<n; ++j) {",
//       "int m = grid.size(), n = grid[0].size(), ans =0; \n vector<vector<int> > dp(m, vector<int>(n, INT_MAX)); \n  int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};",
//       "int nx = p[0] + dx[k], ny = p[1] + dy[k], ndis = p[2] + 1;",
//       "class Ques {",
//       "public:",
//       "queue<vector<int> > q;",
//       "if(nx < 0 || nx >= m || ny < 0 || ny >= n) \n continue; \n if(ndis < dp[nx][ny]) {",
//       "int function(vector<vector<int>>& grid) {",
//       "for(int k=0; k<4; ++k) {",
//       "auto p = q.front();",
//       "dp[i][j] = 0; \n q.push({i, j, 0}); \n } \n } \n",
//       "dp[nx][ny] = ndis;",
//       "};",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 22,
//     day: 2,
//     order: [
//       "int function(vector<vector<int>>& grid) {",
//       "int n = grid.size(); \n vector<int> zeros(n, 0); \n int ans = 0;",
//       "if(n == 0)",
//       "return 0;",
//       "for(int i=0; i<n; i++){",
//       "for(int j=n-1; j>=1; j--){",
//       "if(grid[i][j] == 0)",
//       "zeros[i]++;",
//       "else",
//       "break; \n } \n }",
//       "for(int i=0; i<n-1; i++){",
//       "int req = n-i-1; \n int k=i;",
//       "while(k < n && min(req, zeros[k]) != req)",
//       "k++;",
//       "if(k == n)",
//       "return -1;",
//       "ans += (k - i);",
//       "while(k > i){",
//       "swap(zeros[k], zeros[k-1]);",
//       "k--; \n } \n }",
//       "return ans; \n }",
//     ],
//     code: [
//       "while(k < n && min(req, zeros[k]) != req)",
//       "swap(zeros[k], zeros[k-1]);",
//       "int n = grid.size(); \n vector<int> zeros(n, 0); \n int ans = 0;",
//       "else",
//       "for(int j=n-1; j>=1; j--){",
//       "int function(vector<vector<int>>& grid) {",
//       "ans += (k - i);",
//       "if(k == n)",
//       "int req = n-i-1; \n int k=i;",
//       "if(n == 0)",
//       "break; \n } \n }",
//       "return -1;",
//       "for(int i=0; i<n-1; i++){",
//       "k--; \n } \n }",
//       "return 0;",
//       "zeros[i]++;",
//       "k++;",
//       "return ans; \n }",
//       "while(k > i){",
//       "if(grid[i][j] == 0)",
//       "for(int i=0; i<n; i++){",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 23,
//     day: 2,
//     order: [
//       "class Node{",
//       "public :\nNode *left;\nNode *right;\nint data;\nbool rightThread;",
//       "Node(int data){",
//       " this->data = data;\nrightThread = false;",
//       "this->left = nullptr ;\nthis->right = nullptr ;\n}",
//       "} ;\n Node* leftMostNode(Node *node){",
//       "if(node==nullptr) \n return nullptr;",
//       "else{\nwhile(node->left!=nullptr)",
//       "{\nnode = node->left;\n}",
//       "return node;\n}\n}",
//       "class bst {\npublic :",
//       "bst(){\n}",
//       "void inorder(Node *root, Node *previous){",
//       "if(root==nullptr)\nreturn;",
//       "else{\n inorder(root->right, previous);",
//       " if(root->right==nullptr &&  previous!=nullptr){",
//       " root->right = previous;",
//       "root->rightThread=true;",
//       " }\ninorder(root->left, root);",
//       "}\nvoid convert(Node *root){",
//       "inorder(root, nullptr);\n}\n  } ;",
//     ],
//     code: [
//       "}\nvoid convert(Node *root){",
//       "} ;\n Node* leftMostNode(Node *node){",
//       "Node(int data){",
//       " }\ninorder(root->left, root);",
//       "return node;\n}\n}",
//       " root->right = previous;",
//       "if(node==nullptr) \n return nullptr;",
//       "root->rightThread=true;",
//       "inorder(root, nullptr);\n}\n  } ;",
//       "class bst {\npublic :",
//       " if(root->right==nullptr &&  previous!=nullptr){",
//       "class Node{",
//       "this->left = nullptr ;\nthis->right = nullptr ;\n}",
//       "else{\n inorder(root->right, previous);",
//       "void inorder(Node *root, Node *previous){",
//       "bst(){\n}",
//       "{\nnode = node->left;\n}",
//       "else{\nwhile(node->left!=nullptr)",
//       "if(root==nullptr)\nreturn;",
//       "public :\nNode *left;\nNode *right;\nint data;\nbool rightThread;",
//       " this->data = data;\nrightThread = false;",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 24,
//     day: 2,
//     order: [
//       "int findMax(vector<vector<int>> const &M) \n {",
//       "if (M.size() == 0)",
//       "return 0;",
//       "int n = M.size(); \n int K[n][n]; \n int max = M[n-1][n-1];",
//       "K[n-1][n-1] = M[n-1][n-1];",
//       "for (int j = n-2; j >= 0; j--) \n {",
//       "if (M[n-1][j] > max) { \n max = M[n-1][j]; \n }",
//       "K[n-1][j] = max; \n }",
//       "max = M[n-1][n-1];",
//       "for (int i = n-2; i >= 0; i--) \n {",
//       "if (M[i][n-1] > max) { \n max = M[i][n-1]; \n }",
//       "K[i][n-1] = max; \n }",
//       "max = INT_MIN;",
//       "for (int a = n-2; a >= 0; a--) \n {",
//       "for (int b = n-2; b >= 0; b--) \n {",
//       "if (K[a+1][b+1] - M[a][b] > max)",
//       "max = K[a+1][b+1] - M[a][b];",
//       "K[a][b] = std::max(M[a][b], std::max(K[a][b+1], K[a+1][b])); \n } \n }",
//       "return max; \n }",
//     ],
//     code: [
//       "for (int a = n-2; a >= 0; a--) \n {",
//       "K[i][n-1] = max; \n }",
//       "return max; \n }",
//       "if (K[a+1][b+1] - M[a][b] > max)",
//       "for (int j = n-2; j >= 0; j--) \n {",
//       "if (M.size() == 0)",
//       "K[n-1][j] = max; \n }",
//       "max = K[a+1][b+1] - M[a][b];",
//       "int n = M.size(); \n int K[n][n]; \n int max = M[n-1][n-1];",
//       "max = M[n-1][n-1];",
//       "max = INT_MIN;",
//       "int findMax(vector<vector<int>> const &M) \n {",
//       "K[a][b] = std::max(M[a][b], std::max(K[a][b+1], K[a+1][b])); \n } \n }",
//       "for (int i = n-2; i >= 0; i--) \n {",
//       "if (M[n-1][j] > max) { \n max = M[n-1][j]; \n }",
//       "return 0;",
//       "K[n-1][n-1] = M[n-1][n-1];",
//       "if (M[i][n-1] > max) { \n max = M[i][n-1]; \n }",
//       "for (int b = n-2; b >= 0; b--) \n {",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 25,
//     day: 2,
//     order: [
//       "void function1(vector<vector<int>> matrix)",
//       "{",
//       "int top = 0, \n left = 0, \n right = matrix[0].size()-1,\n bottom = matrix.size()-1;",
//       "while (top<=bottom && left<=right)",
//       "{ \n for (int i = left; i <= right; i++){",
//       "cout<<matrix[top][i]; \n }",
//       "top++;",
//       "for (int i = top; i <= bottom; i++) \n cout<<matrix[i][right]; ",
//       "right--; \n if(top<=bottom)",
//       "for (int i = right ; i >= left; i--)",
//       "cout<<matrix[bottom][i]; ",
//       "bottom--;",
//       "if(left<=right)",
//       "for (int i = bottom ; i >= top; i--)",
//       "cout<<matrix[i][left];",
//       "left++; \n }",
//       "}",
//       "int main() \n { \n int r, c, temp;",
//       "cin >> r >> c;",
//       "vector<vector<int>> arr(r);",
//       "for (int i = 0; i < r; i++) \n {",
//       "for (int j = 0; j < c; j++) \n {",
//       "cin >> temp; \n arr[i].push_back(temp); \n } \n }",
//       "function1(arr);",
//       "return 0; \n }",
//     ],
//     code: [
//       "}",
//       "right--; \n if(top<=bottom)",
//       "void function1(vector<vector<int>> matrix)",
//       "{ \n for (int i = left; i <= right; i++){",
//       "top++;",
//       "int top = 0, \n left = 0, \n right = matrix[0].size()-1,\n bottom = matrix.size()-1;",
//       "function1(arr);",
//       "cin >> temp; \n arr[i].push_back(temp); \n } \n }",
//       "for (int i = bottom ; i >= top; i--)",
//       "return 0; \n }",
//       "bottom--;",
//       "left++; \n }",
//       "cout<<matrix[bottom][i]; ",
//       "vector<vector<int>> arr(r);",
//       "cout<<matrix[top][i]; \n }",
//       "{",
//       "for (int i = 0; i < r; i++) \n {",
//       "while (top<=bottom && left<=right)",
//       "cout<<matrix[i][left];",
//       "for (int i = right ; i >= left; i--)",
//       "int main() \n { \n int r, c, temp;",
//       "for (int j = 0; j < c; j++) \n {",
//       "if(left<=right)",
//       "cin >> r >> c;",
//       "for (int i = top; i <= bottom; i++) \n cout<<matrix[i][right]; ",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 26,
//     day: 2,
//     order: [
//       "class Ques {",
//       "public int function(int[][] grid) {",
//       "int m = grid.length; \n int n = grid[0].length; \n int dp[][][] = new int[m][n][n];",
//       "for (int row = m - 1; row >= 0; row--) {",
//       "for (int col1 = 0; col1 < n; col1++) {",
//       "for (int col2 = 0; col2 < n; col2++) {",
//       "int result = 0;",
//       "result += grid[row][col1]; \n if (col1 != col2)",
//       "result += grid[row][col2];",
//       "if (row != m - 1) {",
//       "int max = 0;",
//       "for (int newCol1 = col1 - 1; newCol1 <= col1 + 1; newCol1++) {",
//       "for (int newCol2 = col2 - 1; newCol2 <= col2 + 1; newCol2++) {",
//       "if (newCol1 >= 0 && newCol1 < n && newCol2 >= 0 && newCol2 < n) ",
//       "max = Math.max(max, dp[row + 1][newCol1][newCol2]); \n } \n }",
//       "result += max; \n }",
//       "dp[row][col1][col2] = result; \n }",
//       "} \n }",
//       "return dp[0][0][n - 1]; \n } \n }",
//     ],
//     code: [
//       "result += max; \n }",
//       "int result = 0;",
//       "} \n }",
//       "if (newCol1 >= 0 && newCol1 < n && newCol2 >= 0 && newCol2 < n) ",
//       "return dp[0][0][n - 1]; \n } \n }",
//       "result += grid[row][col2];",
//       "public int function(int[][] grid) {",
//       "max = Math.max(max, dp[row + 1][newCol1][newCol2]); \n } \n }",
//       "result += grid[row][col1]; \n if (col1 != col2)",
//       "if (row != m - 1) {",
//       "class Ques {",
//       "for (int newCol1 = col1 - 1; newCol1 <= col1 + 1; newCol1++) {",
//       "for (int row = m - 1; row >= 0; row--) {",
//       "dp[row][col1][col2] = result; \n }",
//       "int m = grid.length; \n int n = grid[0].length; \n int dp[][][] = new int[m][n][n];",
//       "int max = 0;",
//       "for (int newCol2 = col2 - 1; newCol2 <= col2 + 1; newCol2++) {",
//       "for (int col1 = 0; col1 < n; col1++) {",
//       "for (int col2 = 0; col2 < n; col2++) {",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 27,
//     day: 2,
//     order: [
//       "class Ques {\nint INF=1e9+5;",
//       "public:",
//       "int function(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {",
//       "int n=passingFees.size(); \n vector<vector<pair<int,int>>>g(n); \n  int ans=INF;",
//       "for(auto &v:edges){",
//       "g[v[0]].push_back({v[1],v[2]}); \n g[v[1]].push_back({v[0],v[2]}); \n }",
//       "set<pair<int,pair<int,int>>>st; \n vector<int>t1(n,INF); \n vector<int>fees(n,INF);",
//       "st.insert({passingFees[0],{0,0}}); \n t1[0]=0; \n fees[0]=passingFees[0];",
//       "while(!st.empty()){",
//       "int node=(*st.begin()).second.first,time=(*st.begin()).second.second,cost=(*st.begin()).first;",
//       "st.erase(st.begin());",
//       "if(node==n-1){",
//       "ans=cost;",
//       "break;",
//       "} \n if(cost!=fees[node] && time!=t1[node]){ ",
//       "continue; \n }",
//       "for(auto &child:g[node]){",
//       "int cost1=cost+passingFees[child.first]; \n int time1=time+child.second; \n int node1=child.first;",
//       "if(time1<=maxTime && (t1[node1]>time1||fees[node1]>cost1)){",
//       "t1[node1]=min(t1[node1],time1); \n fees[node1]=min(fees[node1],cost1); \n st.insert({cost1,{node1,time1}});",
//       "} \n } \n }",
//       "if(ans==INF)",
//       "ans=-1;",
//       "return ans;",
//       "} \n };",
//     ],
//     code: [
//       "while(!st.empty()){",
//       "int cost1=cost+passingFees[child.first]; \n int time1=time+child.second; \n int node1=child.first;",
//       "break;",
//       "set<pair<int,pair<int,int>>>st; \n vector<int>t1(n,INF); \n vector<int>fees(n,INF);",
//       "class Ques {\nint INF=1e9+5;",
//       "int function(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {",
//       "st.insert({passingFees[0],{0,0}}); \n t1[0]=0; \n fees[0]=passingFees[0];",
//       "if(ans==INF)",
//       "public:",
//       "st.erase(st.begin());",
//       "} \n } \n }",
//       "} \n if(cost!=fees[node] && time!=t1[node]){ ",
//       "return ans;",
//       "} \n };",
//       "int n=passingFees.size(); \n vector<vector<pair<int,int>>>g(n); \n  int ans=INF;",
//       "continue; \n }",
//       "ans=-1;",
//       "int node=(*st.begin()).second.first,time=(*st.begin()).second.second,cost=(*st.begin()).first;",
//       "for(auto &v:edges){",
//       "t1[node1]=min(t1[node1],time1); \n fees[node1]=min(fees[node1],cost1); \n st.insert({cost1,{node1,time1}});",
//       "g[v[0]].push_back({v[1],v[2]}); \n g[v[1]].push_back({v[0],v[2]}); \n }",
//       "ans=cost;",
//       "for(auto &child:g[node]){",
//       "if(time1<=maxTime && (t1[node1]>time1||fees[node1]>cost1)){",
//       "if(node==n-1){",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 28,
//     day: 2,
//     order: [
//       "struct Job {",
//       "int deadline, duration, idx;",
//       "bool operator<(Job o) const",
//       "return deadline < o.deadline;",
//       "};",
//       "vector<int> function(vector<Job> jobs) {",
//       "sort(jobs.begin(), jobs.end()); \n set<pair<int,int>> s; \n vector<int> schedule;",
//       "for (int i = jobs.size()-1; i >= 0; i--) {",
//       "int t = jobs[i].deadline - (i ? jobs[i-1].deadline : 0); \n s.insert(make_pair(jobs[i].duration, jobs[i].idx));",
//       "while (t && !s.empty()) { ",
//       "auto it = s.begin();",
//       "if (it->first <= t) {",
//       "t -= it->first; \n schedule.push_back(it->second) \n }",
//       "else {",
//       "s.insert(make_pair(it->first - t, it->second)); \n t = 0; \n }",
//       "s.erase(it); \n } \n }",
//       "return schedule;",
//       "}",
//     ],
//     code: [
//       "s.erase(it); \n } \n }",
//       "vector<int> function(vector<Job> jobs) {",
//       "int deadline, duration, idx;",
//       "sort(jobs.begin(), jobs.end()); \n set<pair<int,int>> s; \n vector<int> schedule;",
//       "auto it = s.begin();",
//       "int t = jobs[i].deadline - (i ? jobs[i-1].deadline : 0); \n s.insert(make_pair(jobs[i].duration, jobs[i].idx));",
//       "bool operator<(Job o) const",
//       "s.insert(make_pair(it->first - t, it->second)); \n t = 0; \n }",
//       "for (int i = jobs.size()-1; i >= 0; i--) {",
//       "if (it->first <= t) {",
//       "return schedule;",
//       "while (t && !s.empty()) { ",
//       "else {",
//       "return deadline < o.deadline;",
//       "struct Job {",
//       "};",
//       "}",
//       "t -= it->first; \n schedule.push_back(it->second) \n }",
//     ],
//   },
// ]);
// Question.insertMany([
//   {
//     level: 29,
//     day: 2,
//     order: [
//       "typedef struct func {",
//       "uint8_t s1Cnt; \n uint8_t s2Cnt; \n uint8_t s3Cnt;",
//       "func(uint8_t s1C, uint8_t s2C, uint8_t s3C) {",
//       "s1Cnt = s1C; \n s2Cnt = s2C; \n s3Cnt = s3C; \n }",
//       "} func;",
//       "class Ques {",
//       "public:",
//       "bool function(string s1, string s2, string s3) {",
//       "uint8_t s1Size = s1.size(); \n uint8_t s2Size = s2.size(); \n uint8_t s3Size = s3.size();",
//       "vector<vector<bool>> memo (s1Size + 1, vector<bool>(s2Size + 1)); \n stack<func> buffStk;",
//       "buffStk.push(func(0, 0, 0));",
//       "while (!buffStk.empty()) {",
//       "func currBuff = buffStk.top();",
//       "buffStk.pop();",
//       "uint8_t currS1Cnt = currBuff.s1Cnt; \n uint8_t currS2Cnt = currBuff.s2Cnt;",
//       "uint8_t currS3Cnt = currBuff.s3Cnt; \n if (currS1Cnt == s1Size && currS2Cnt == s2Size && currS3Cnt == s3Size)",
//       "return true;",
//       "if (memo[currS1Cnt][currS2Cnt]) \n continue;",
//       "memo[currS1Cnt][currS2Cnt] = true;",
//       "if (currS1Cnt < s1Size && s1[currS1Cnt] == s3[currS3Cnt]) {",
//       "buffStk.push(func(",
//       "currS1Cnt + 1,",
//       "currS2Cnt,",
//       "currS3Cnt + 1",
//       ")); \n } \n if (currS2Cnt < s2Size && s2[currS2Cnt] == s3[currS3Cnt]) {",
//       "buffStk.push(func(currS1Cnt, currS2Cnt + 1, \n currS3Cnt + 1)); \n }",
//       "} \n return false; \n }",
//       "};",
//     ],
//     code: [
//       "uint8_t s1Cnt; \n uint8_t s2Cnt; \n uint8_t s3Cnt;",
//       "} \n return false; \n }",
//       ")); \n } \n if (currS2Cnt < s2Size && s2[currS2Cnt] == s3[currS3Cnt]) {",
//       "func currBuff = buffStk.top();",
//       "uint8_t currS3Cnt = currBuff.s3Cnt; \n if (currS1Cnt == s1Size && currS2Cnt == s2Size && currS3Cnt == s3Size)",
//       "};",
//       "while (!buffStk.empty()) {",
//       "if (memo[currS1Cnt][currS2Cnt]) \n continue;",
//       "bool function(string s1, string s2, string s3) {",
//       "buffStk.push(func(0, 0, 0));",
//       "return true;",
//       "public:",
//       "currS2Cnt,",
//       "memo[currS1Cnt][currS2Cnt] = true;",
//       "uint8_t currS1Cnt = currBuff.s1Cnt; \n uint8_t currS2Cnt = currBuff.s2Cnt;",
//       "if (currS1Cnt < s1Size && s1[currS1Cnt] == s3[currS3Cnt]) {",
//       "} func;",
//       "s1Cnt = s1C; \n s2Cnt = s2C; \n s3Cnt = s3C; \n }",
//       "uint8_t s1Size = s1.size(); \n uint8_t s2Size = s2.size(); \n uint8_t s3Size = s3.size();",
//       "class Ques {",
//       "buffStk.pop();",
//       "currS3Cnt + 1",
//       "currS1Cnt + 1,",
//       "buffStk.push(func(currS1Cnt, currS2Cnt + 1, \n currS3Cnt + 1)); \n }",
//       "buffStk.push(func(",
//       "vector<vector<bool>> memo (s1Size + 1, vector<bool>(s2Size + 1)); \n stack<func> buffStk;",
//       "func(uint8_t s1C, uint8_t s2C, uint8_t s3C) {",
//       "typedef struct func {",
//     ],
//   },
// ]);

// Question.insertMany([
//   {
//     level: 30,
//     day: 2,
//     order: [
//       "bool isSpace(char c) {",
//       "return c == ' ';\n}",
//       "void function(string &s, int n)\n{",
//       " bool space = false;\nint k = 0;",
//       "for (int i = 0; i < n; i++)\n{",
//       "while (k == 0 && i < n && isSpace(s[i])) {\ni++;\n}",
//       "if (isSpace(s[i]))\n{",
//       "if (!space)\n{",
//       "s[k++] = s[i];\nspace = true;\n}",
//       "}\nelse if (ispunct(s[i]))\n{",
//       " if (k > 0 && isSpace(s[k-1])) {",
//       " s[k-1] = s[i];\n}",
//       "else {",
//       "s[k++] = s[i];\n}",
//       "space = false;\n}",
//       "else {\ns[k++] = s[i];\nspace = false;",
//       " }\n}\ns.erase(s.begin() + k - 1, s.end());",
//       "}",
//     ],
//     code: [
//       "else {\ns[k++] = s[i];\nspace = false;",
//       "return c == ' ';\n}",
//       " if (k > 0 && isSpace(s[k-1])) {",
//       "else {",
//       " }\n}\ns.erase(s.begin() + k - 1, s.end());",
//       "s[k++] = s[i];\n}",
//       " bool space = false;\nint k = 0;",
//       "for (int i = 0; i < n; i++)\n{",
//       "if (!space)\n{",
//       "s[k++] = s[i];\nspace = true;\n}",
//       " s[k-1] = s[i];\n}",
//       "if (isSpace(s[i]))\n{",
//       "}\nelse if (ispunct(s[i]))\n{",
//       "space = false;\n}",
//       "}",
//       "bool isSpace(char c) {",
//       "void function(string &s, int n)\n{",
//       "while (k == 0 && i < n && isSpace(s[i])) {\ni++;\n}",
//     ],
//   },
// ]);
