      1
      
       "a[i] = $.extend(true, {}, a[i]); \n }\n a.map(descaleBlock);\n	});",
       "for (var i = 0; i < state.blocks.length; i++) \n {",
      "function exportSaveState() \n {",
       "hex: $.extend(true, {}, MainHex), \n blocks: $.extend(true, [], blocks),\n score: score, \n	wavegen: waveone, \n gdx: gdx, \n	gdy: gdy, \n",
      "} \n state.blocks.map(descaleBlock); \n	} \n }",
       "if(gameState == 1 || gameState == -1 || (gameState === 0 && localStorage.getItem('saveState') !== undefined)) \n { \n state =",
       "state.blocks[i] = $.extend(true, {}, state.blocks[i]);",
       "comboTime:settings.comboTime \n	}; \n	state.hex.blocks.map(function(a) \n { \n	for (var i = 0; i < a.length; i++) \n { \n",
       "var state = { \n };",

      ---------------------------------------------------------------------

      2

             "let targetRect = target.getBoundingClientRect();",
       "if (x > targetRect.width) \n { \n x = targetRect.width \n};",
       " };",
    "onMouseMove = (e) => \n {",
       "color.style.width = percentPosition ; \n tooltip.style.left = btn.x - 5 ; \n tooltip.style.opacity = 1; \n tooltip.textContent = Math.round(percentPosition);",
       "e.preventDefault();",
       "btn.x = x - 10; \n btn.style.left = btn.x ; \n let percentPosition = (btn.x + 10) / targetRect.width * 100;",
       "let x = e.pageX - targetRect.left + 10;",
       "else  if (x < 0) \n { x = 0 \n};",

       --------------------------------------------------------------------
       3
          
      "namespace draco \n {",
       "return keyframe_animation_.SetTimestamps(timestamps_); \n }\n}",
       "timestamps_[i] = static_cast<draco::KeyframeAnimation::TimestampType>(i);",
       "class KeyframeAnimationEncodingTest : public ::testing::Test \n { \n protected: ",
       "timestamps_.resize(num_frames);",
       "bool CreateAndAddTimestamps(int32_t num_frames) \n {",
       "KeyframeAnimationEncodingTest() \n { \n }",
       "for (int i = 0; i < timestamps_.size(); ++i)",

     ----------------------------------------------------------------------

     4

                "return 'yes';",
       "if ( compare & 1 ) ",
       "return a;",
       "return b; \n}",
       "if ( a === b ) \n {",
       "} \n var compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?",
       "return 0; \n}",
       "{ \n if ( a == document || a.ownerDocument == document && jQuery.contains( document, a ))",
  "function sortOrder( a, b ) \n {",
       "var hasDuplicate = true;",
       "else if ( b == document || b.ownerDocument == document && jQuery.contains( document, b )) \n{",
       "a.compareDocumentPosition( b ) :1;",

     ----------------------------------------------------------------------

     5

      "int t(int x, int y)",
       "{ \n x = x * x;",
       "return z; \n }",
       " y = y - 1;    \n } \n }",
       "{ \n if (y % 2 == 0)",
       "{ \n int z = 1;",
       "else \n {",
       "while (y > 0) ",
       " y = y / 2; \n }",
       "z = z * x;",


     ----------------------------------------------------------------------

     6

            "</html>",
       "</head>",
       "<script src='./index.js'>",
       "<body>",
       "<li>or a state</li>",
       "</body>",
       "<form class='search-form'>",
       "</script>",
       "<head>",
       "<title>Type Ahead ðŸ‘€</title>",
       "</form>",
       "</ul>",
      "<link rel='stylesheet' href='style.css'>",
"<html>",
       "<input type='text' class='search' placeholder='City or State'>",
       "<li>Filter for a city</li>",
       "<meta charset='UTF-8'>",

     ----------------------------------------------------------------------

     7
       "e++; \n  }",
       "push(*e); \n }",
       "if(isalnum(*e))",
       "else \n {",
       "printf('%c',pop());",
    "while(*e != '\0') \n {",
       " while((x = pop()) != '(')",
       "printf('%c', x);}",
       "printf('%c',*e); \n else if(*e == '(')",
       "push(*e);",
       "else if(*e == ')') \n {",
      "while(priority(stack[top]) >= priority(*e))",
     ----------------------------------------------------------------------

     8
       "if (!user)",
       "const isMatch = await user.matchPassword(password);",
       "return next(new ErrorResponse('user doesn't exist', 401));",
       "return next(new ErrorResponse('Invalid credentials', 401));",
       "const user = await User.findOne({ email }).select('+password');",
       "} \n catch (err) \n {",
          "try \n {",
       "if (!isMatch) ",
       "sendToken(user, 200, res);",
       "next(err); \n }",

     ----------------------------------------------------------------------

     9

              "<ul>",
      "<head>",
       "<body>",
       "<div class='container'>",
       "<script src='./index.js'>",
       "<li><a href='/logout'>Logout</a></li>",
       "</body>",
       "<link rel='stylesheet' href='../css/main.css'>",
       "<meta charset='UTF-8'>",
       "</script>",
       "</center>",
       "<center>",
       "<nav class='navbar'>",
       "<div class='navbar-links'>",
       "<div class='navbar-brand'>",
      "</head>",
       "<title> BlogIN </title>\n<link rel='icon' href='logo.png' type='image/png' />",
       "</div>",
       "<img src='logo.png' alt='' style='width: 120px;height: 120px'> \n </div>",
       "<p style='font-size:50px;padding-top:40px;font-weight:bold'>Publish your Passions, your way <br> Let's started   Blogging !</p>",
       "</ul>\n </div>",
       "</nav>",

    
     ----------------------------------------------------------------------

     11
      "return (std::pow(expected, x) * std::exp(-expected)) / fact(x);\n}",
     "if (f1 <= 0) ",
      "double f1 = x;",
    "double function(double x) {",
      "double function2(double expected, double lower, double upper) {",
      " double f2 = 0;",
      "  f1 = 1;",
      "  f2+= function1(expected, i);\n}",
      "for (int i = x - 1; i > 0; i--) {",
      "double function1(double expected, double x) {",
      "return f1;\n}",
      "for (int i = lower; i <= upper; i++) {",
      "}",
      "return f2;\n}",
      "  f1 *= i;\n }",
     ----------------------------------------------------------------------

     12
            " array[j] = array[j - gap];\n}",
       "cmp = cmp || compare;",
       "for (var j = i;j >= gap && cmp(array[j - gap], current) > 0; j -= gap) {",
       "}",
       "current = array[i];",
       "array[j] = current;\n}",
       "for (var i = gap; i < array.length; i += gap) {",
        "var gap, current;",
 "return function (array, cmp) {",
       "return array;\n};",
       "for (var k = 0; k < gaps.length; k += 1) {",
       "gap = gaps[k]",


     ----------------------------------------------------------------------
     13
            "[ \n matrix[columnIndex][rowIndex],",
       "for (let rowIndex = 0; rowIndex < matrix.length; rowIndex += 1) {",
       "const matrix = originalMatrix.slice();",
       " } \n }",
       "matrix[rowIndex][columnIndex], \n matrix[columnIndex][rowIndex],",
      "return matrix;",
       "matrix[rowIndex][columnIndex], \n ] = [",
       "[ \n matrix[rowIndex][matrix.length - columnIndex - 1],",
       "matrix[rowIndex][columnIndex], \n ] = [",
       "matrix[rowIndex][columnIndex], \n matrix[rowIndex][matrix.length - columnIndex - 1], \n ];",

       "];\n } \n }",
       "}",
 "export default function f1(originalMatrix) {",
       "for (let columnIndex = rowIndex + 1; columnIndex < matrix.length; columnIndex += 1) {",
       "for (let rowIndex = 0; rowIndex < matrix.length; rowIndex += 1) { ",
       "for (let columnIndex = 0; columnIndex < matrix.length / 2; columnIndex += 1) {",

       -----------------------------------------------------------------

       14

              "right--; \n if(top<=bottom)",
       "while (top<=bottom && left<=right)",
       "}",
   "void function1(vector<vector<int>> matrix)",
       "cout<<matrix[top][i]; \n }",
       "function1(arr);",
       "top++;",
       "int top = 0, \n left = 0, \n right = matrix[0].size()-1,\n bottom = matrix.size()-1;",
       "for (int i = bottom ; i >= top; i--)",
       "int main() \n { \n int r, c, temp;",
       "for (int j = 0; j < c; j++) \n {",
       "for (int i = 0; i < r; i++) \n {",
       "{ \n for (int i = left; i <= right; i++){",
       "for (int i = top; i <= bottom; i++) \n cout<<matrix[i][right]; ",
       "bottom--;",
      "left++; \n }",
       "if(left<=right)",
       "cout<<matrix[bottom][i]; ",
       "{",
       "cout<<matrix[i][left];",
       "return 0; \n }",
       "cin >> temp; \n arr[i].push_back(temp); \n } \n }",
       "vector<vector<int>> arr(r);",
       "for (int i = right ; i >= left; i--)",
       "cin >> r >> c;",


       -----------------------------------------------------------------

       15

              "for(auto it : adj[node]) {",
       "queue<int> q; \n vector<int> v(N, 0);",
       "for(int i = 0;i<N;i++) {",
      "if(v[it] == 0) { ",
       "q.push(it); \n } \n } \n }",
       "public:",
       "int node = q.front(); ",
       "q.push(i); \n } \n } \n int cnt = 0;",
       "while(!q.empty()) {",
       "return false; ",
 "class CodePazuru {",
       "if(cnt == N) ",
       "v[it]++; \n } \n  }",
       "};",
       "return true; \n }",
       "q.pop(); \n  cnt++; ",
       "for(int i = 0;i<N;i++) { \n for(auto it: adj[i]) { ",
       "v[it]--;",
       "bool function1(int N, vector<int> adj[]) {",
       "if(v[i] == 0) {",

       -------------------------------------------------------------------
    16

           "++i; \n ++j; \n}",
       "void function1(long long a[], long long b[], int n, int m){",
       "};",
       "if (a[i] > b[j - n]) swap(a[i], b[j - n]); \n }",
       "int i = 0, j = gap;",
       "while (gap) {",
       "else if (i < n && j >= n) {",
       "int gap = (n + m + 1) / 2;",
       "if (a[i] > a[j]) swap(a[i], a[j]); \n }",
 "class CodePazuru{",
       "if (b[i - n] > b[j - n]) swap(b[i - n], b[j - n]); \n }",
       "else{ ",
       "public:",
       "{ \n if (i < n && j < n) {",
       "gap = gap < 2 ? 0 : (gap + 1) / 2; \n } \n } ",
       "while (j < (n + m)) ",

       --------------------------------------------------------------------
        17

            "if (root == nullptr) { \n return; \n }",
        "else {\nNode* child = (root->left)? root->left: root->right;",
"}",
           " else {\nrotateRight(root);\ndeleteNode(root->right, key);\n}\n}",
   " if (key < root->data) {\n deleteNode(root->left, key);\n}",
       " else if (root->left && root->right)\n{",

          "  delete curr;\n}\n}",
    "else if (key > root->data) {\ndeleteNode(root->right, key);\n}",
            "if (root->left->priority < root->right->priority)\n{\nrotateLeft(root);\ndeleteNode(root->left, key);\n}",
       " if (root->left == nullptr && root->right == nullptr)\n{\ndelete root;\nroot = nullptr;\n}",
"void deleteNode(Node* &root, int key) \n {",
    "else {",
          " Node* curr = root;\nroot = child;",

       --------------------------------------------------------------------

       18
       
                   "if (root->left->priority < root->right->priority)\n{\nrotateLeft(root);\ndeleteNode(root->left, key);\n}",
    "else {",
"}",
"void deleteNode(Node* &root, int key) \n {",
    "else if (key > root->data) {\ndeleteNode(root->right, key);\n}",
   " if (key < root->data) {\n deleteNode(root->left, key);\n}",
        "else {\nNode* child = (root->left)? root->left: root->right;",
    "if (root == nullptr) { \n return; \n }",
          " Node* curr = root;\nroot = child;",
          "  delete curr;\n}\n}",

       " else if (root->left && root->right)\n{",
           " else {\nrotateRight(root);\ndeleteNode(root->right, key);\n}\n}",
       " if (root->left == nullptr && root->right == nullptr)\n{\ndelete root;\nroot = nullptr;\n}",

       --------------------------------------------------------------------

        19

               " s[k-1] = s[i];\n}",
"bool isSpace(char c) {",
            "s[k++] = s[i];\nspace = false;",
            "if (!space)\n{",
"void function(string &s, int n)\n{",
    "return c == ' ';\n}",
   " bool space = false;\nint k = 0;",
        "if (isSpace(s[i]))\n{",
        "while (k == 0 && i < n && isSpace(s[i])) {\ni++;\n}",
       " }\n}\ns.erase(s.begin() + k - 1, s.end());",
        "else {",
            "else {",
        "}\nelse if (ispunct(s[i]))\n{",
                "s[k++] = s[i];\nspace = true;\n}",
           " if (k > 0 && isSpace(s[k-1])) {",
                "s[k++] = s[i];\n}",
    "for (int i = 0; i < n; i++)\n{",
            "space = false;\n}",

       --------------------------------------------------------------------
        20

        "}",
        "function_5(a, begin, a + pivot - 1, maxdepth - 1);\nfunction_5(a, a + pivot + 1, end, maxdepth - 1);",
    "else {",
"int function_3(int a[], int low, int high) {",
           " a[j] = a[j - 1];",
           " pIndex++;",
      "  if (a[i] <= pivot)\n{",
        "while (j > low && a[j - 1] > value)\n{",
   " for (int i = low; i < high; i++)\n{",
       " int pivot = function_3(a, begin - a, end - a);",
    "swap(a[pivotIndex], a[high]);\nreturn function_2(a, low, high);",
   " make_heap(begin, end);",
"void function_1(int a[], int low, int high)\n{",
        "}\n}",
"}",
 "   if ((end - begin) < 16) {\nfunction_1(a, begin - a, end - a);\n}",
          "  swap(a[i], a[pIndex]);",
"void function_5(int a[], int *begin, int *end, int maxdepth)\n{",
   " return pIndex;\n}",
    "int pivotIndex = rand() % (high - low + 1) + low;",
   " sort_heap(begin, end);\n}",
"void function_4(int *begin, int *end)\n{",
            "j--;\n}",
   " }\n}",
   " else if (maxdepth == 0) {\nfunction_4(begin, end + 1);\n}",
        "a[j] = value;\n}",
    "int pivot = a[high];\nint pIndex = low;",
    "for (int i = low + 1; i <= high; i++)\n{\nint value = a[i];\nint j = i;",
   " swap (a[pIndex], a[high]);",
"int function_2(int a[], int low, int high)\n{",


       --------------------------------------------------------------------

       21

        "s.erase(val); \n s.insert(p[i]); \n f++;",
    "else{",
  "for (int i = 0; i < n; i++){",
  "unordered_set<int> s; \n unordered_map<int, int> id; \n int f = 0, m = INT_MIN, val;",
          "if (id[*it] > m) \n {"
    "if (s.find(p[i]) == s.end()){ \n for (auto it = s.begin(); it != s.end(); it++) \n {",
    "} \n id[p[i]] = i; \n } \n }",
   "int function(int p[], int n, int fr) {",
  "return f; \n }",
    "if (s.size() < fr){",
      "if (s.find(p[i]) == s.end()){ \n s.insert(p[i]); \n f++; \n }",
            "m = id[*it]; \n val = *it; \n } \n }",
      "id[p[i]] = i; \n }",

       -------------------------------------------------------------------
       22

                       " for (int j = 0; j < N; j++)\n{",
                " }\n}",
       "for (int i = M - 2; i >= 0; i--)\n{",
                    "count[mat[i][j]] += 1;\nmaxArea = Integer.max(maxArea, mat[i][j] * count[mat[i][j]]);\n}\n}\n}",
      "  for (int i = 0; i < mat.length; i++)\n{",
                "if (mat[i][j] != 0) {\nmat[i][j] = 1;\n}",
                "if (mat[i][j] > 0)\n{",
           " int[] count = new int[M + 1];\nfor (int j = 0; j < N; j++)\n{",
            "}\n}\n}",
       " for (int i = 0; i < M; i++)\n{",
        "if (mat == null || mat.length == 0) ",
                "if (mat[i][j] == 1) \nmat[i][j] = mat[i+1][j] + 1;",
        "return maxArea;",
   " public static int function_2(int[][] mat)\n{",
    " public static void function_1(int[][] mat)\n{",
           " for (int j = 0; j < mat[0].length; j++)\n{",
          "  return 0;\nint M = mat.length;\nint N = mat[0].length;\nint maxArea = 0;",
    "}",
        "function_2(mat);",
       -------------------------------------------------------------------
       23
                "first = first->right;\nsecond = second->right;\n}",
   " function_3(y, second, prev);",
"bool function_1(Node* node) {",
    "function_2(root->left, head, prev);",
        "if (prev == nullptr) \nhead = root;",
        "else \nprev->right = root;",
    "prev = nullptr;",
"}",
    "if (root == nullptr) \nreturn;",
   " while (first && second && first->key == second->key)\n{",
    "Node* prev = nullptr;",
"void function_2(Node* root, Node* &head, Node* &prev)\n{",
   " Node* first = nullptr;",
    "Node* second = nullptr;",
   " function_2(root->right, head, prev);\n}",
   " if (function_!(root))\n{",
        "prev = root;\n}",
   " return node->left == nullptr && node->right == nullptr;\n}",
    "function_2(x, first, prev);",
    "return !first && !second;",
"bool function_3(Node* x, Node* y)\n{",

       --------------------------------------------------------------------
        24

           "int function(vector<int> &p, int k) \n {",
            "else {",
        "} \n } \n return pr[k][n-1]; \n }",
    "for (int i = 0; i <= k; i++) \n {",
                "pr[i][j] = 0;",
            "if (i == 0 || j == 0)",
                    "if (max < curr)",
                       "max = curr; \n }",
                    "int curr = p[j] - p[k] + pr[i-1][k];",
    "int n = p.size(), pr[k+1][n];",
                "pr[i][j] = max(pr[i][j-1], max); \n }",
                "int max = 0; \nfor (int k = 0; k < j; k++) \n {",
        "for (int j = 0; j < n; j++){",


       --------------------------------------------------------------------
        25

        "row = it.second;",
            "if (parent[i] == false && mat[row][i]){",
        "node[row] = new Node(row);",
       "multimap.insert({ sum, i }); \n } \n for (int i = 0; i < N; i++) {",
            "sum += (int)mat[i][j];",
       "for (int j = 0; j < N; j++)",
        "for (int i = 0; i < N; i++){",
                "else \n node[row]->right = node[i];",    
       " if (it.first == 0) \n continue;",
   "multimap<int, int> multimap; \n Node* node[N]; \n int row; \n bool parent[N] = false;",
        "parent[i] = false; \n }",
                "parent[i] = true; \n }",
                "if (node[row]->left == nullptr) \n node[row]->left = node[i];",
        "} \n } \n return node[row]; \n }",
"Node* function_1(bool mat[][N]){",
   "for (int i = 0; i < N; i++) \n { \n int sum = 0;",
   "for (auto it: multimap){",


       --------------------------------------------------------------------
       26

                    "lbs_len = (I[i] + D[i] - 1)",
            "I[i] = I[i - 1] + 1",
        "if A[i - 1] < A[i]:",
   " for i in reversed(range(len(A) - 1)):",
        "return",
   " for i in range(len(A)):",
       "if A[i] > A[i + 1]:",
"def func(A):",
            "beg = i - I[i] + 1 \n end = i + D[i] - 1",
        "if lbs_len < I[i] + D[i] - 1:",
            "D[i] = D[i + 1] + 1",
    "if len(A) == 0:",
    "I = [1] * len(A) \n D = [1] * len(A) \n lbs_len = 1 \n beg = end = 0",

       --------------------------------------------------------------------

        27

        " for it in A:",
        "freq[j] = total \n total += oldCount",
"def func(A, k):",
      "freq[i] = freq[i] + 1",
       "output[freq[it]] = it \n freq[it] = freq[it] + 1",
    "for a in range(len(A)):",
    "for i in A:",
        "A[a] = output[a]",
       "oldCount = freq[j]",
    "output = [0] * len(A) \n freq = [0] * (k + 1) \n total = 0",
    "for j in range(k + 1):",

       --------------------------------------------------------------------
    28


        "else:",
        "x = X[i] \n y = Y[i]",
    "if len(X) != len(Y):",
"def func(X, Y):",
        "if x in dict:",
            "dict[x] = y \n s.add(y)",
            "if dict[x] != y:",
    "dict = {} \n s = set()",
            "if y in s:",
    "for i in range(len(X)):",
                "return False",
    "return True",
        "return False",
                "return False",

       --------------------------------------------------------------------

       29
            "return 0;",
    "return max; \n }",
    "max = INT_MIN;",           
            "if (K[a+1][b+1] - M[a][b] > max)",
    "K[n-1][n-1] = M[n-1][n-1];",
            "K[a][b] = std::max(M[a][b], std::max(K[a][b+1], K[a+1][b])); \n } \n }",
        "K[n-1][j] = max; \n }",
"int findMax(vector<vector<int>> const &M) \n {",
    "for (int j = n-2; j >= 0; j--) \n {",
    "max = M[n-1][n-1];",   
        "K[i][n-1] = max; \n }",
    "if (M.size() == 0)",
    "for (int i = n-2; i >= 0; i--) \n {",
        "if (M[n-1][j] > max) { \n max = M[n-1][j]; \n }",
    "for (int a = n-2; a >= 0; a--) \n {",
        "for (int b = n-2; b >= 0; b--) \n {",
    "int n = M.size(); \n int K[n][n]; \n int max = M[n-1][n-1];",
        "if (M[i][n-1] > max) { \n max = M[i][n-1]; \n }",
                "max = K[a+1][b+1] - M[a][b];",

       ------------------------------------------------------------------
        30
      "while (true) \n {",
      "int M = lists.size(); \n int high = INT_MIN; \n pair<int, int> p = { 0, INT_MAX };" , "priority_queue<Node, vector<Node>, comp> pq;",
      "if (lists.size() == 0)", 
              "p = {low, high};",
          "high = max(high, lists[i][j + 1]); \n } \n }",
              "return p;",
          "if (high - low < p.second - p.first) ",
 "pair<int, int> findMinimumRange(vector<vector<int>> lists) \n {",
          "if (lists[i].size() == 0)", 
          "high = max(high, lists[i][0]); \n }",
          "if (j == lists[i].size() - 1)",
          "pq.pop();",
          "return {-1, -1};",
      "for (int i = 0; i < M; i++)\n {",
          "int low = pq.top().value; \n int i = pq.top().list_num; \n int j = pq.top().index;",
          "pq.push({lists[i][0], i, 0});",
              "return {-1, -1};",
          "pq.push({lists[i][j + 1], i, j + 1});",

        ------------------------------------------------------------------

        31

            "for (int j = n-2; j >= 0; j--) \n {",
    "int n = M.size(); \n int K[n][n]; \n int max = M[n-1][n-1];",
        "if (M[n-1][j] > max) { \n max = M[n-1][j]; \n }",
            "if (K[a+1][b+1] - M[a][b] > max)",
    "max = M[n-1][n-1];",   
    "for (int a = n-2; a >= 0; a--) \n {",
            "K[a][b] = std::max(M[a][b], std::max(K[a][b+1], K[a+1][b])); \n } \n }",
"int findMax(vector<vector<int>> const &M) \n {",
        "if (M[i][n-1] > max) { \n max = M[i][n-1]; \n }",
        "K[n-1][j] = max; \n }",
        "K[i][n-1] = max; \n }",
    "for (int i = n-2; i >= 0; i--) \n {",
                "max = K[a+1][b+1] - M[a][b];",
    "if (M.size() == 0)",
    "return max; \n }",
    "max = INT_MIN;",           
        "return 0;",
    "K[n-1][n-1] = M[n-1][n-1];",
        "for (int b = n-2; b >= 0; b--) \n {",

        -------------------------------------------------------------------

        33

        		"categories.insert({\n'name': name,\n}, function(err, post){",
			"else {",
  "var name = req.body.name; \n var errors = req.validationErrors();",
"});",
				"req.flash('success','Category Added');",
			"}\n});\n}",
	" else {\nvar categories = db.get('categories');",
"router.post('/add', function(req, res, next) {",
	"if(errors)",
		"res.render('addpost',{\n'errors': errors\n});",
				"res.location('/');",
	"req.checkBody('name','Name field is required').notEmpty();",
			"if(err)",
				"res.send(err);",

        ------------------------------------------------------------------

        34

      "<div id='namesWrapper#1'>",
        "<div id='chatWrapper#2'>",
          "<input type='submit' value='Submit'>",
          "<div id='chatWindow'></div>\n<form id='messageForm'>",
        "</form>\n</div>",
        "<form id='usernameForm'>",
            "<input type='text' size='35' id='message' placeholder='Say Something...'>",
          "<input type='text' size='35' id='username'>",
            "<input type='submit' value='Submit'>\n</form>",
  "<div id='container'>",
        "<h2>ChatIO</h2>",
        "</div>\n</div>",


        -------------------------------------------------------------------

        35

				"echo 'C'",
			"fi\nelse\necho 'D'",
"fi",
					"else",
"echo 'Total marks : $sum '",
	"fi\nelse\necho 'F'",
				"fi\nelse",
					"if [ $sum -gt 450 ]; then",
			"if [ $sum -gt 350 ]; then",
"echo 'Grade : '",
		"if [ $sum -gt 300 ]; then",
				"if [ $sum -gt 400 ]; then",
						"echo 'S'",
						"echo 'A'\nfi",
		"fi\nelse\necho 'E'",
				"else\necho 'B'",
	"if [ $sum -gt 250 ]; then",
"if [ $sum -gt 200 ]; then",


        -------------------------------------------------------------------
        36

                               "else {\nvar user_id = results[0].id;\nvar published;",
      "msg = '';\nif (req.session.loggedIn) {",
          "'select id from users where email = ?  ',",
                "[title, content, user_id, published],\n(err, results, fields) => {",
              "if (publish == 'true') published = 1;",
            "if (error) ",
              "db.query(\n'insert into posts (title,content,user_id,published) values (?,?,?,?)  ',",
                  "if (err) \nres.render('challenges/error');",
          "}\n);\n} else ",
              "else published = 0;",
                   "else {\nmsg = 'Blog Created Successfully';",
      "router.post('/add_new_post', (req, res) => {",
        "res.redirect('login');",
                    "res.redirect("/");",
        "var title = req.body.title;\nvar content = req.body.content;\nvar publish = req.body.publish;",
              "res.render('challenges/error');",
        "db.query(",
                  "}\n}\n);\n}",
          "[req.session.email],\n(error, results, fields) => {",
    "});",
        ------------------------------------------------------------------

        37

                  "return pool.query(",
    " FROM game )",
      "exports.leaderboard = (callback) => {",
    "};",
        "callback );",
    " WHERE Ranks >= 1 and Ranks <=10",
    " ROW_NUMBER()",
    " OVER( ",
    " AS Ranks",
    "ORDER BY Score desc)",
    "SELECT *,",
        "'WITH Ranking AS (",
    " SELECT rollno , score ,ranks",
    " FROM Ranking",
    "  ORDER BY Ranks ',",


        -------------------------------------------------------------------

        38

          "let token;",
"};",
 " return next(new ErrorResponse('Not authorized to access this router', 401));\n}",
    "const user = await User.findById(decoded.id);",
    "if (!user) \nreturn next(new ErrorResponse('No user found with this id', 404));",
 " } catch (err) {",
    "req.user = user;\nnext();",
 " try {",
  "if (\nreq.headers.authorization &&\nreq.headers.authorization.startsWith('Bearer')\n)" ,
"exports.protect = async (req, res, next) => {",
    "token = req.headers.authorization.split(' ')[1];",
   " const decoded = jwt.verify(token, process.env.JWT_SECRET);",
    "return next(new ErrorResponse('Not authorized to access this route', 401));",
  "if (!token) ",



        -------------------------------------------------------------------

        39
        			   		"else:\nmessages.info(request, 'Invalid username or password')",
"def loginView(request):",
			"if user.is_admin or user.is_superuser:",
		    "return redirect('home')",
		"user = authenticate(request, username=username, password=password)",
		"if user is not None and user.is_active:",
			"auth.login(request, user)",
			    "return redirect('publisher')",
	"if request.method == 'POST':",
		"username = request.POST['username']\npassword = request.POST['password']",
			"elif user.is_librarian:",
			"else:",
				"return redirect('librarian')",
				"return redirect(' Admin dashboard')",
        -------------------------------------------------------------------

        40
        "}\nreturn value;",
            "? fn( value, that[i], i, that ) ",
          "value = isSet ",
      "{	\nvar i = start,\nvalue,\nisSet = false;",
   "function func ( that, fn, init, start, end, inc )",
            "continue;",
            "{",
          "if ( ! that.hasOwnProperty(i) ) ",
            ":that[i];\nisSet = true;\ni += inc;",
      "}",
          "value = init;\nisSet = true;\n}",
        "while ( i !== end ) {",
        "if ( init !== undefined )", 



        -------------------------------------------------------------------

        41
      "int deadline, duration, idx;",
              "auto it = s.begin();",
      "sort(jobs.begin(), jobs.end()); \n set<pair<int,int>> s; \n vector<int> schedule;",
      "return schedule;",
      "struct Job {",
               "else {",
          "while (t && !s.empty()) { ",
  "};",
  "vector<int> function(vector<Job> jobs) {",
              "s.erase(it); \n } \n }",
      "bool operator<(Job o) const",
      "for (int i = jobs.size()-1; i >= 0; i--) {",
          "return deadline < o.deadline;",  
  "}",
              "if (it->first <= t) {",
                  "t -= it->first; \n schedule.push_back(it->second) \n }",
                  "s.insert(make_pair(it->first - t, it->second)); \n t = 0; \n }",
          "int t = jobs[i].deadline - (i ? jobs[i-1].deadline : 0); \n s.insert(make_pair(jobs[i].duration, jobs[i].idx));",


        -------------------------------------------------------------------

        42

        "SELECT",
            "COUNT(DISTINCT e2.Salary)",
            "e2.Salary > e1.Salary",
"WHERE",
";",
    "Department d ON e1.DepartmentId = d.Id",
        "FROM",
    "d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary",
            "Employee e2",
        ")",
    "Employee e1",
    "3 > (SELECT",
                "AND e1.DepartmentId = e2.DepartmentId",
"FROM",
        "WHERE",
        "JOIN",

        -------------------------------------------------------------------

        43

           " } catch (err) {",
      "const res = await axios.get('/api/auth');",
"const AuthState = props => {",
      "dispatch({ type: AUTH_ERROR });",
  "const [state, dispatch] = useReducer(authReducer, initialState);",
  "  try {",
  "const loadUser = async () => {",
 " const initialState = {\ntoken: localStorage.getItem('token'),\nisAuthenticated: null,\nloading: true,\nuser: null,\nerror: null\n};",
    "}\n};",
      "dispatch({\ntype: USER_LOADED,\npayload: res.data\n});",
    "setAuthToken(localStorage.token);",

        -------------------------------------------------------------------
        44

                "const { register, errors, handleSubmit } = useForm();",
      "const onSubmit = (data) => {",
         " <input type='submit' />",
          "<FormSection1 register={register} />",
   "export default function App() {",
      "return (",
       " <form onSubmit={handleSubmit(onSubmit)}>",
      "};",
        "alert(JSON.stringify(data));",
      "  </form>",
    " );\n }",

        -------------------------------------------------------------------

        45

                  "if (localStorage.getItem('userInfo')) {\nhistory.push('/');",
      "}\n};",
       " if (userinfo) {\nhistory.push('/game');\n}",
      "useEffect(() => {",
      "}\n}, [history]);",
        "localStorage.setItem('userInfo', JSON.stringify(data));",
      "try {",
      "} catch (error) {",
        "setError(error.response.data.error);",
    "const loginHandler = async (e) => {",
        "const { data } = await axios.post(\n'/api/auth/login',\n{ email, password },\nconfig\n);",
        "setTimeout(() => {\nsetError('');\n}, 5000);",
     " const config = {",
      "e.preventDefault();",
     " };",
         " 'Content-Type': 'application/json',\n}",
       " const userinfo = localStorage.getItem('userInfo');",
       " header: {",

        -------------------------------------------------------------------

        46
               "this.logoutHandler = this.logoutHandler.bind(this);",
      " componentDidMount() {",
      " constructor(props) {",
         "this.state = {\nusername: '',\n};",
         "super(props);",
        " this.props.history.push('./login');\n}\n}",
         "localStorage.removeItem('userInfo');",
       "}\n logoutHandler() {",
         "this.fetch();",
  "class error_page extends Component {",
      " }",

        -------------------------------------------------------------------

        47

        "  }\n}\n})",
         " } else {",
             " loadQuiz()",
         "\n' quiz.innerHTML = `\n<h2>You answered ${score}/${quizData.length} questions correctly</h2>\n<button onclick='location.reload()'>Reload</button>`",
      "const answer = getSelected()",   
              "score++\n}",
          "if(currentQuiz < quizData.length) {",
  "submitBtn.addEventListener('click', () => {",
      "if(answer) {",
         " currentQuiz++",
          "if(answer === quizData[currentQuiz].correct) {",


        -------------------------------------------------------------------

        48

            "titleLabel.text = item.title\nif let location = item.location {",
  "override func viewDidLoad() {",
  "var item: ToDoItem?",
  "private func centerMapOnLocation(with coordinate: CLLocationCoordinate2D) {",
       " centerMapOnLocation(with: cooridnate)",
"class DetailViewController: UIViewController {",
      "if let cooridnate = location.coordinate {",
    "let coordinateRegion = MKCoordinateRegion(center: coordinate, latitudinalMeters: regionRadius, longitudinalMeters: regionRadius)",
    "guard let item = item else {\nreturn\n}",
   " super.viewDidLoad()",
    "mapView.setRegion(coordinateRegion, animated: true)\n}\n}",
      "}\n}\n}",
  "@IBOutlet var titleLabel: UILabel!\n@IBOutlet var mapView: MKMapView!\n@IBOutlet var locationLabel: UILabel!",
     " locationLabel.text = location.name",
   " let regionRadius: CLLocationDistance = 1000",


        -------------------------------------------------------------------

        49

    "public:",
            "st.erase(st.begin());",
                "int cost1=cost+passingFees[child.first]; \n int time1=time+child.second; \n int node1=child.first;",
        "set<pair<int,pair<int,int>>>st; \n vector<int>t1(n,INF); \n vector<int>fees(n,INF);",
                "continue; \n }",
            "int node=(*st.begin()).second.first,time=(*st.begin()).second.second,cost=(*st.begin()).first;",
"class Ques {\nint INF=1e9+5;",
	"st.insert({passingFees[0],{0,0}}); \n t1[0]=0; \n fees[0]=passingFees[0];",
        "return ans;",
                "} \n } \n }",
            "if(node==n-1){",
        "int n=passingFees.size(); \n vector<vector<pair<int,int>>>g(n); \n  int ans=INF;",
                    "t1[node1]=min(t1[node1],time1); \n fees[node1]=min(fees[node1],cost1); \n st.insert({cost1,{node1,time1}});",
                "if(time1<=maxTime && (t1[node1]>time1||fees[node1]>cost1)){", 
        "while(!st.empty()){",
            "g[v[0]].push_back({v[1],v[2]}); \n g[v[1]].push_back({v[0],v[2]}); \n }",
                "break;",
	     "} \n if(cost!=fees[node] && time!=t1[node]){ ",
        "for(auto &v:edges){",
    "} \n };",
    "int function(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {",
            "ans=-1;",
        "if(ans==INF)",
            "for(auto &child:g[node]){",
                "ans=cost;",

        ------------------------------------------------------------------

        50
           "return res && (grid1[a][b]==1); \n } ",
          "grid2[a][b]=0; \n bool res = true;",
      "bool fn(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int a, int b) \n {",
              "for(int j=0;j<m;j++) \n {",
          "return count; \n }",
          "for(int i=0;i<n;i++) \n {",
              "int x = a + dir[i][0]; \n int y = b + dir[i][1];",
                  "if(grid2[i][j]==1)",
      "int function(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {",
      "};",
      "public:",
      "class Ques {",
      "vector<vector> dir={{-1,0},{1,0},{0,1},{0,-1}};",
          "int n= grid1.size(), m= grid1[0].size(), count = 0;",
                      "count+= fn(grid1, grid2, i, j)?1:0; \n } \n }",
              "if(x>=0 && y>=0 && x< grid1.size() && y< grid1[0].size() && grid2[x][y]==1)",   
                  "res&= fin(grid1, grid2, x, y); \n }",
          "for(int i=0;i<4;i++) {",


        ------------------------------------------------------------------

        51

      "};",
"public:",
        "else if(mid+1>nums.size()-1){",
    "int mind(vector<vector<int>> &mat, int target){",
            "else\n return 0; \n }",
            "if(nums[mid][target]<nums[mid+1][target]) \n return 1;",
        "return ind; \n }",
        "return {l,ind}; \n }",
"class Ques {",
    "vector<int> function(vector<vector<int>>& mat) {\nint l = 0, h = mat.size(), ind = 0;",
            "else if (t==1) \n l = mid+1;",
            "if(nums[mid][target] > nums[mid-1][target]) \n return 0;",
                "ind = i; \n mn = mat[target][i]; \n } \n }",
        "int ind = 0, mn = 0;",
            "else \n return -1; \n } \n }",
        "if(mid-1 < 0){",
            "else if(nums[mid+1][target]>nums[mid-1][target]) \n return 1;",
            "int mid = (l+h)/2;",
    "int ch(vector<vector<int>> &nums, int mid, int target){",
            "return -1; \n }",
        "for(int i = 0;i<mat[0].size();i++){",
        "while(l<h){",
            "int t = ch(mat,mid,ind);",
        "else{",
            "if(t==0) \n return {mid,ind};",
            "else \n h = mid; \n }",
            "if(nums[mid][target]>nums[mid+1][target] && nums[mid-1][target]< nums[mid][target]) \n return 0;",
            "if(mat[target][i] > mn){",
            "ind = mind(mat, mid);",



        ------------------------------------------------------------------

        52

                    "for(int j=1;j<=n;j++){",
        "vector<vector<int>> dp(3,vector<int>(n+1,0));",
        "return dp[2][n]; \n ",
        "for(int i=1;i<=2;i++){",
"class Ques {",
                        "int v1 = dp[i][mj]; \n int v2 = dp[i-1][mi]; \n int mx = max(v1,v2);",
                "if(i==1) \n dp[i][j] = j;",
                "else if(j==1) \n dp[i][j] =1;",
                "else{",
"};",
                    "dp[i][j] = 1 + mn; \n } \n } \n }",
    "int twoEggDrop(int n) {",
                    "for(int mj=j-1,mi=0;mj>=0;mj--,mi++){",
                    "int mn = INT_MAX;",
"public:",
                       "mn = min(mn,mx); \n }",


        ------------------------------------------------------------------

        53

                    "string s1 = s.substr(i,1); \n isPallin[i][i] = 1; \n int l=i-1, r = i+1;",
        "int n = s.size(); \n for(int i=0;i<n-2;i++){",
                "if(isPallin[0][i]==1 && isPallin[i+1][j]==1 && isPallin[j+1][n-1]==1) ",
                "left--; right++; \n } \n }",
"class Ques {",
"};",
                "isPallin[l][r] = 1;",
"public:",
        "vector<vector<int>>isPallin(2001, vector<int>(2001,0));",
                "l--; \n r++; \n }",
    "bool function(string s) {",
            "int left = i, right = i+1;\n while(left>=0 && right<s.size() && s[left]==s[right]){",
        "for(int i=0;i<s.size();i++){",
            "for(int j=i+1;j<n-1;j++)",
                "isPallin[left][right] = 1;",
        "return false; \n }",
			"return true; \n }",
            "while(l>=0 &&  r<s.size() && s[l]==s[r]){",


        ------------------------------------------------------------------
        54

                    "e ^= encoded[i];",
        "for ( int i = 1; i < n; ++i )",
        "int po = x ^ e;",
"class Ques {",
"public:",
        "for ( int i = 1; i <= n; ++i )",
	"perm[0] = po;",
"};",
        "const int n = encoded.size() + 1; \n int x = 0, e=0",
        "for ( int i = 1; i < encoded.size(); i += 2 )",
            "x ^= i;",
            "perm[i] = perm[i-1] ^ encoded[i-1];",
    "std::vector<int> decode(std::vector<int>& encoded) { \n std::vector<int> perm(n, 0);",
        "return perm; \n }",

        ------------------------------------------------------------------

        55

                    "return -1;",
"int function(vector<vector<int>>& grid) {",
            "else",
    "if(n == 0)",
                "zeros[i]++;",
    "for(int i=0; i<n-1; i++){",
    "for(int i=0; i<n; i++){",
    "int n = grid.size(); \n vector<int> zeros(n, 0); \n int ans = 0;",
        "while(k < n && min(req, zeros[k]) != req)",
            "k++;",
        "for(int j=n-1; j>=1; j--){",
        "while(k > i){",
        "ans += (k - i);",
            "k--; \n } \n }",
                "break; \n } \n }",
        "if(k == n)",
        "int req = n-i-1; \n int k=i;",
    "return ans; \n }",
            "swap(zeros[k], zeros[k-1]);",
        "return 0;",
            "if(grid[i][j] == 0)",


        -----------------------------------------------------------------

        56
                            "if(down[i][j]>=k and down[i][j+k-1]>=k and right[i][j]>=k and right[i+k-1][j]>=k)",
            "for(int j=c-1;j>=0;j--){ \n if(grid[i][j]) \n p++;",
        "int r=grid.size(); \n int c=grid[0].size(); \n int down[r][c]; \n  int right[r][c]; \n int k=min(r,c);",
            "for(int i=r-1;i>=0;i--){",
        "for(int i=0;i<r;i++){ \n int p=0;",
                "else",
                "else \n p=0; \n right[i][j]=p; \n } \n }",
                "down[i][j]=p; \n } \n }",
                    "p=0;",   
        "for(int j=0;j<c;j++){",
                "if(grid[i][j])",
        "while(k>0){",
        "return 0;",
"int function(vector<vector<int>>& grid) {",
                        "return k*k;",
            "for(int i=0;i<=r-k;i++)",
            "k--; \n }",
                "for(int j=0;j<=c-k;j++)",
"}",
            "int p=0;",
                   "p++;",
             ----------------------------------------------------

             57

                         
        "vector<vector<bool>> memo (s1Size + 1, vector<bool>(s2Size + 1)); \n stack<SearchBuff> buffStk;",
                ")); \n } \n if (currS2Cnt < s2Size && s2[currS2Cnt] == s3[currS3Cnt]) {",
        "while (!buffStk.empty()) {",
        "buffStk.push(SearchBuff(0, 0, 0));",
        "s1Cnt = s1C; \n s2Cnt = s2C; \n s3Cnt = s3C; \n }",
"typedef struct SearchBuff {",
"public:",
    "uint8_t s1Cnt; \n uint8_t s2Cnt; \n uint8_t s3Cnt;",
"} SearchBuff;",
        "} \n return false; \n }",
                "buffStk.push(SearchBuff(currS1Cnt, currS2Cnt + 1, \n currS3Cnt + 1)); \n }",
        "uint8_t s1Size = s1.size(); \n uint8_t s2Size = s2.size(); \n uint8_t s3Size = s3.size();",
                    "currS2Cnt,",
"};",
    "bool function(string s1, string s2, string s3) {",
                    "currS3Cnt + 1",
                    "currS1Cnt + 1,",
                "buffStk.push(SearchBuff(",
            "if (currS1Cnt < s1Size && s1[currS1Cnt] == s3[currS3Cnt]) {",
            "if (memo[currS1Cnt][currS2Cnt]) \n continue;",
    "SearchBuff(uint8_t s1C, uint8_t s2C, uint8_t s3C) {",
            "uint8_t currS1Cnt = currBuff.s1Cnt; \n uint8_t currS2Cnt = currBuff.s2Cnt;",
            "memo[currS1Cnt][currS2Cnt] = true;",
            "buffStk.pop();",
	    "uint8_t currS3Cnt = currBuff.s3Cnt; \n if (currS1Cnt == s1Size && currS2Cnt == s2Size && currS3Cnt == s3Size)",
                "return true;",
            "SearchBuff currBuff = buffStk.top();",
"class Ques {",

-----------------------------------------------------------------------

58

                            "for (int newCol2 = col2 - 1; newCol2 <= col2 + 1; newCol2++) {",
                    "result += grid[row][col1]; \n if (col1 != col2)",    
                    "dp[row][col1][col2] = result; \n }",
                "for (int col2 = 0; col2 < n; col2++) {",
"class Ques {",
                    "int result = 0;",
                      "max = Math.max(max, dp[row + 1][newCol1][newCol2]); \n } \n }",
            "for (int col1 = 0; col1 < n; col1++) {",
        "return dp[0][0][n - 1]; \n } \n }",
                        "int max = 0;",
                        "result += grid[row][col2];",
            "} \n }",
    "public int function(int[][] grid) {",
        "for (int row = m - 1; row >= 0; row--) {",
        "int m = grid.length; \n int n = grid[0].length; \n int dp[][][] = new int[m][n][n];",
                        "result += max; \n }",
                        "for (int newCol1 = col1 - 1; newCol1 <= col1 + 1; newCol1++) {",
                    "if (row != m - 1) {",
                                "if (newCol1 >= 0 && newCol1 < n && newCol2 >= 0 && newCol2 < n) ",

----------------------------------------------------------------------
59
            "q.pop();",
                "int nx = p[0] + dx[k], ny = p[1] + dy[k], ndis = p[2] + 1;",   
"};",
            "auto p = q.front();",
        "return ans == 0 ? -1 : ans; \n }",
"class Ques {",
                "if(nx < 0 || nx >= m || ny < 0 || ny >= n) \n continue; \n if(ndis < dp[nx][ny]) {",
        "int m = grid.size(), n = grid[0].size(), ans =0; \n vector<vector<int> > dp(m, vector<int>(n, INT_MAX)); \n  int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};",
                    "dp[nx][ny] = ndis;",
                    "ans = max(ans, ndis); \n } \n } \n }",
                    "q.push({nx, ny, ndis});",
        "queue<vector<int> > q;",
        "while(!q.empty()) {",
        "for(int i=0; i<m; ++i) {",
"public:",
                    "dp[i][j] = 0; \n q.push({i, j, 0}); \n } \n } \n",
    "int function(vector<vector<int>>& grid) {",
            "for(int j=0; j<n; ++j) {",
            "for(int k=0; k<4; ++k) {",
                "if(grid[i][j] == 1) {",

--------------------------------------------------------------------------
hard 60 
            "while(sz--) {",
                "auto [r, c] = q.front(); q.pop();",
			 "continue;",
                "else if(grid[r][c] == 1)",
            "count++; \n }",
       
 	"return -1;",
                    "int nr = r + DIR[i], nc = c + DIR[i+1];",
		 "f++; \n } \n }",
"vector<int> DIR = {0, 1, 0, -1, 0};",
        "for (int r = 0; r < m; ++r) {",
                    "f--; \n } \n }",
                "queue<pair<int, int>> que;",
                    "q.emplace(nr, nc);",
                    "if (nr < 0 || nr == m || nc < 0 || nc == n || grid[nr][nc] != 1)",
        "return max(0,count); \n }",
        "int m = grid.size(), \n n = grid[0].size(), \n count=-1, \n f=0; \n queue<pair<int, int>> q;",
            "for (int c = 0; c < n; ++c) {",
                "for (int i = 0; i < 4; ++i) {",

    "int function(vector<vector<int>>& grid) {",
		 "q.emplace(r, c);",
            "int sz=q.size();",
        "if(f>0)",
            
        
                    "grid[nr][nc] = grid[r][c];",
        "while (!q.empty()) {",
                "if (grid[r][c] == 2)",

